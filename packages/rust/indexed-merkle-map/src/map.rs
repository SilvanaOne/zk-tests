//! IndexedMerkleMap implementation for use outside zkVM
//! This contains the full data structure and methods for managing the tree

extern crate alloc;

use alloc::vec::Vec;
use alloc::vec;
use alloc::collections::BTreeMap;
use crate::types::{
    Field, Hash, Leaf, MembershipProof, NonMembershipProof, 
    InsertWitness, UpdateWitness, MerkleProof, hash_pair, IndexedMerkleMapError
};
use crate::provable::ProvableIndexedMerkleMap;

/// The IndexedMerkleMap structure
/// This struct should only be used outside zkVM. Inside zkVM, use ProvableIndexedMerkleMap
/// with witnesses/proofs generated by this structure.
pub struct IndexedMerkleMap {
    height: usize,
    // Sparse storage: (level, index) -> Hash
    // Only non-zero hashes are stored, significantly reducing memory usage
    nodes: BTreeMap<(usize, usize), Hash>,
    sorted_leaves: Vec<Leaf>,         // sorted by key
    leaf_indices: BTreeMap<Field, usize>, // key -> leaf index in tree
    internal_root: Hash,
    next_index: usize,
}

impl IndexedMerkleMap {
    /// Create a new IndexedMerkleMap with the given height
    pub fn new(height: usize) -> Self {
        assert!(height > 0 && height <= 32, "Height must be between 1 and 32");

        let mut nodes = BTreeMap::new();

        // Initialize with first leaf (0, 0, 0)
        let first_leaf = Leaf::empty();
        let first_hash = first_leaf.hash();
        
        // Store first leaf at level 0, index 0
        nodes.insert((0, 0), first_hash);
        
        // Build up the tree to root
        let mut current_hash = first_hash;
        for level in 1..height {
            nodes.insert((level, 0), current_hash);
            current_hash = hash_pair(&current_hash, &Hash::zero());
        }

        let mut leaf_indices = BTreeMap::new();
        leaf_indices.insert(Field::zero(), 0);

        IndexedMerkleMap {
            height,
            nodes,
            sorted_leaves: vec![first_leaf],
            leaf_indices,
            internal_root: current_hash,
            next_index: 1,
        }
    }

    /// Get a node from the sparse storage, returning Hash::zero() if not present
    fn get_node(&self, level: usize, index: usize) -> Hash {
        self.nodes.get(&(level, index))
            .copied()
            .unwrap_or(Hash::zero())
    }
    
    /// Set a node in the sparse storage, removing it if it's zero (to save memory)
    fn set_node(&mut self, level: usize, index: usize, hash: Hash) {
        if hash == Hash::zero() {
            // Don't store zeros - they're implicit
            self.nodes.remove(&(level, index));
        } else {
            self.nodes.insert((level, index), hash);
        }
    }

    /// Get the current merkle root (combines internal root with length for security)
    pub fn root(&self) -> Hash {
        // Use the provable version's combine method
        ProvableIndexedMerkleMap::combine_root_with_length(&self.internal_root, self.next_index)
    }

    /// Find the leaf with the largest key less than the given key
    /// Uses binary search for O(log n) performance
    fn find_low_leaf(&self, key: &Field) -> &Leaf {
        // Binary search to find the position where key would be inserted
        match self.sorted_leaves.binary_search_by_key(key, |leaf| leaf.key) {
            // Key exists exactly - the low leaf is the previous one
            Ok(idx) => {
                if idx == 0 {
                    &self.sorted_leaves[0]  // Key is the first element, return itself
                } else {
                    &self.sorted_leaves[idx - 1]
                }
            },
            // Key doesn't exist - Err(idx) gives insertion point
            Err(idx) => {
                if idx == 0 {
                    &self.sorted_leaves[0]  // Key would be inserted at beginning
                } else {
                    &self.sorted_leaves[idx - 1]  // Return the leaf just before insertion point
                }
            }
        }
    }

    /// Get merkle proof for a leaf at given index
    fn get_merkle_proof(&self, leaf_index: usize) -> MerkleProof {
        let mut siblings = Vec::new();
        let mut path_indices = Vec::new();
        let mut index = leaf_index;
        
        for level in 0..self.height - 1 {
            let is_right = index % 2 == 1;
            path_indices.push(is_right);
            
            let sibling_index = if is_right { index - 1 } else { index + 1 };
            let sibling = self.get_node(level, sibling_index);
            siblings.push(sibling);
            
            index /= 2;
        }
        
        MerkleProof { siblings, path_indices }
    }

    /// Update the merkle tree after modifying a leaf
    fn update_tree(&mut self, leaf_index: usize, new_leaf_hash: Hash) {
        // Set the leaf hash at level 0
        self.set_node(0, leaf_index, new_leaf_hash);
        
        let mut index = leaf_index;
        for level in 0..self.height - 1 {
            let parent_index = index / 2;
            
            let left_child = self.get_node(level, parent_index * 2);
            let right_child = self.get_node(level, parent_index * 2 + 1);
            
            let parent_hash = hash_pair(&left_child, &right_child);
            
            if level + 1 == self.height - 1 {
                self.internal_root = parent_hash;
            } else {
                self.set_node(level + 1, parent_index, parent_hash);
            }
            
            index = parent_index;
        }
    }

    /// Insert a new key-value pair (standard version for non-zkVM usage)
    pub fn insert(&mut self, key: Field, value: Field) -> Result<(), IndexedMerkleMapError> {
        // Call the witness version with generate_witness = false
        self.insert_and_generate_witness(key, value, false)?;
        Ok(())
    }
    
    /// Insert a new key-value pair and optionally generate a complete witness for zkVM verification
    /// If generate_witness is true, returns the complete witness
    /// If false, returns None (more efficient for non-zkVM usage)
    pub fn insert_and_generate_witness(&mut self, key: Field, value: Field, generate_witness: bool) -> Result<Option<InsertWitness>, IndexedMerkleMapError> {
        // Check if key already exists
        if self.leaf_indices.contains_key(&key) {
            return Err(IndexedMerkleMapError::KeyAlreadyExists);
        }
        
        // Check if tree is at capacity
        let max_leaves = 1usize << (self.height - 1);  // 2^(height-1) leaves
        if self.next_index >= max_leaves {
            return Err(IndexedMerkleMapError::TreeFull);
        }

        // === Collect witness data if needed ===
        let old_root = if generate_witness { self.root() } else { Hash::zero() };
        let old_tree_length = self.next_index;

        // Find the low leaf
        let low_leaf = self.find_low_leaf(&key).clone();
        
        // Verify that key is between low_leaf.key and low_leaf.next_key
        if key <= low_leaf.key || (low_leaf.next_key != Field::zero() && key >= low_leaf.next_key) {
            return Err(IndexedMerkleMapError::InvalidProof);
        }

        // Get proofs for witness if needed
        let low_leaf_index = self.leaf_indices[&low_leaf.key];
        let low_leaf_proof_before = if generate_witness {
            self.get_merkle_proof(low_leaf_index)
        } else {
            MerkleProof { siblings: vec![], path_indices: vec![] }
        };
        
        let non_membership_proof = if generate_witness {
            NonMembershipProof {
                low_leaf: low_leaf.clone(),
                merkle_proof: low_leaf_proof_before.clone(),
            }
        } else {
            NonMembershipProof {
                low_leaf: low_leaf.clone(),
                merkle_proof: MerkleProof { siblings: vec![], path_indices: vec![] },
            }
        };

        // Create new leaf and updated low leaf
        let new_leaf = Leaf::new(key, value, low_leaf.next_key, self.next_index);
        let updated_low_leaf = Leaf::new(low_leaf.key, low_leaf.value, key, low_leaf.index);
        
        // === Apply updates to the tree ===
        
        // Update tree for low leaf
        self.update_tree(low_leaf_index, updated_low_leaf.hash());
        
        // Update sorted leaves
        for leaf in &mut self.sorted_leaves {
            if leaf.key == low_leaf.key {
                leaf.next_key = key;
                break;
            }
        }
        
        // Get proof for new leaf AFTER low leaf update (only if generating witness)
        // This handles overlapping paths correctly
        let new_leaf_proof_after = if generate_witness {
            self.get_merkle_proof(self.next_index)
        } else {
            MerkleProof { siblings: vec![], path_indices: vec![] }
        };
        
        // Insert new leaf in sorted position
        let insert_pos = self.sorted_leaves.iter().position(|l| l.key > key).unwrap_or(self.sorted_leaves.len());
        self.sorted_leaves.insert(insert_pos, new_leaf.clone());
        
        // Add new leaf to the tree (sparse storage handles it automatically)
        let new_leaf_index = self.next_index;
        self.update_tree(self.next_index, new_leaf.hash());
        
        // Update indices
        self.leaf_indices.insert(key, self.next_index);
        self.next_index += 1;
        
        // === Generate witness if requested ===
        if generate_witness {
            let new_root = self.root();
            
            Ok(Some(InsertWitness {
                old_root,
                new_root,
                key,
                value,
                new_leaf_index,
                tree_length: old_tree_length,
                non_membership_proof,
                low_leaf_proof_before,
                updated_low_leaf,
                new_leaf,
                new_leaf_proof_after,
            }))
        } else {
            Ok(None)
        }
    }

    /// Update the value for an existing key
    pub fn update(&mut self, key: Field, value: Field) -> Result<Field, IndexedMerkleMapError> {
        // Call the witness version with generate_witness = false
        let witness = self.update_and_generate_witness(key, value, false)?;
        Ok(witness.map(|w| w.old_value).unwrap_or(value))
    }
    
    /// Update a key-value pair and optionally generate a complete witness for zkVM verification
    /// If generate_witness is true, returns the complete witness
    /// If false, returns None (more efficient for non-zkVM usage)
    pub fn update_and_generate_witness(&mut self, key: Field, new_value: Field, generate_witness: bool) -> Result<Option<UpdateWitness>, IndexedMerkleMapError> {
        let leaf_index = *self.leaf_indices.get(&key).ok_or(IndexedMerkleMapError::KeyDoesNotExist)?;
        
        // === Collect witness data if needed ===
        let old_root = if generate_witness { self.root() } else { Hash::zero() };
        let tree_length = self.next_index;
        
        // Get membership proof before update if generating witness
        let membership_proof = if generate_witness {
            self.get_membership_proof(&key).ok_or(IndexedMerkleMapError::InvalidProof)?
        } else {
            // Create a dummy proof for when we're not generating witness
            MembershipProof {
                leaf: Leaf::empty(),
                merkle_proof: MerkleProof { siblings: vec![], path_indices: vec![] }
            }
        };
        
        // Find the leaf in sorted_leaves and update it
        let (old_value, updated_leaf) = {
            let leaf = self.sorted_leaves.iter_mut()
                .find(|l| l.key == key)
                .ok_or(IndexedMerkleMapError::KeyDoesNotExist)?;
            
            let old_value = leaf.value;
            leaf.value = new_value;
            let updated_leaf = leaf.clone();
            (old_value, updated_leaf)
        };
        
        // Update the tree
        self.update_tree(leaf_index, updated_leaf.hash());
        
        // === Generate witness if requested ===
        if generate_witness {
            let new_root = self.root();
            
            Ok(Some(UpdateWitness {
                old_root,
                new_root,
                key,
                old_value,
                new_value,
                tree_length,
                membership_proof,
                updated_leaf,
            }))
        } else {
            // Return a minimal witness just for the old_value
            Ok(Some(UpdateWitness {
                old_root: Hash::zero(),
                new_root: Hash::zero(),
                key,
                old_value,
                new_value,
                tree_length: 0,
                membership_proof,
                updated_leaf,
            }))
        }
    }
    
    /// Set a key-value pair (insert or update).
    /// Returns the previous value as an Option (None if the key didn't exist before).
    /// This matches the o1js implementation's set() method.
    pub fn set(&mut self, key: Field, value: Field) -> Option<Field> {
        // Check if key already exists
        if let Some(&leaf_index) = self.leaf_indices.get(&key) {
            // Key exists - update it
            // Find the leaf in sorted_leaves and update it
            let old_value = {
                let leaf = self.sorted_leaves.iter_mut()
                    .find(|l| l.key == key)?;
                
                let old_value = leaf.value;
                leaf.value = value;
                let new_hash = leaf.hash();
                
                // Update the tree
                self.update_tree(leaf_index, new_hash);
                
                old_value
            };
            
            Some(old_value)
        } else {
            // Key doesn't exist - insert it
            // Check if tree is at capacity
            let max_leaves = 1usize << (self.height - 1);
            if self.next_index >= max_leaves {
                // Tree is full, cannot insert
                return None;
            }
            
            // Perform insertion
            match self.insert(key, value) {
                Ok(_) => None, // No previous value
                Err(_) => None, // Insertion failed
            }
        }
    }
    
    /// Get the value associated with a key as an Option.
    /// Returns Some(value) if the key exists, None otherwise.
    /// This matches the o1js implementation's getOption() method.
    pub fn get_option(&self, key: &Field) -> Option<Field> {
        // Check if key exists
        if self.leaf_indices.contains_key(key) {
            // Find the leaf and return its value
            self.sorted_leaves.iter()
                .find(|l| l.key == *key)
                .map(|l| l.value)
        } else {
            None
        }
    }
    
    /// Get the value associated with a key.
    /// Panics if the key doesn't exist.
    /// Use get_option() for a non-panicking version.
    pub fn get(&self, key: &Field) -> Field {
        self.get_option(key)
            .expect("Key does not exist in the map")
    }

    /// Get membership proof for a key
    pub fn get_membership_proof(&self, key: &Field) -> Option<MembershipProof> {
        let leaf_index = *self.leaf_indices.get(key)?;
        
        let leaf = self.sorted_leaves.iter()
            .find(|l| l.key == *key)?
            .clone();
        
        let merkle_proof = self.get_merkle_proof(leaf_index);
        
        Some(MembershipProof { leaf, merkle_proof })
    }

    /// Get non-membership proof for a key
    pub fn get_non_membership_proof(&self, key: &Field) -> Option<NonMembershipProof> {
        if self.leaf_indices.contains_key(key) {
            return None; // Key exists, can't prove non-membership
        }
        
        let low_leaf = self.find_low_leaf(key).clone();
        let low_leaf_index = self.leaf_indices[&low_leaf.key];
        let merkle_proof = self.get_merkle_proof(low_leaf_index);
        
        Some(NonMembershipProof { low_leaf, merkle_proof })
    }
    
    
    pub fn height(&self) -> usize {
        self.height
    }
    
    /// Get the current tree length (number of leaves)
    pub fn length(&self) -> usize {
        self.next_index
    }

    // Test helper methods - only available in test builds
    #[doc(hidden)]
    pub fn sorted_leaves(&self) -> &Vec<Leaf> {
        &self.sorted_leaves
    }

    #[doc(hidden)]
    pub fn next_index(&self) -> usize {
        self.next_index
    }
    
    // === Static verification methods that delegate to ProvableIndexedMerkleMap ===
    
    /// Verify a membership proof (delegates to ProvableIndexedMerkleMap)
    pub fn verify_membership_proof(
        root: &Hash, 
        proof: &MembershipProof, 
        key: &Field, 
        value: &Field, 
        tree_length: usize
    ) -> bool {
        ProvableIndexedMerkleMap::verify_membership_proof(root, proof, key, value, tree_length)
    }
    
    /// Verify a non-membership proof (delegates to ProvableIndexedMerkleMap)
    pub fn verify_non_membership_proof(
        root: &Hash, 
        proof: &NonMembershipProof, 
        key: &Field, 
        tree_length: usize
    ) -> bool {
        ProvableIndexedMerkleMap::verify_non_membership_proof(root, proof, key, tree_length)
    }
    
    /// Verify update with witness (delegates to ProvableIndexedMerkleMap)
    pub fn verify_update(witness: &UpdateWitness) -> Result<(), IndexedMerkleMapError> {
        ProvableIndexedMerkleMap::update(witness)
    }
    
    /// Verify insert with witness (delegates to ProvableIndexedMerkleMap)
    pub fn verify_insert(witness: &InsertWitness) -> Result<(), IndexedMerkleMapError> {
        ProvableIndexedMerkleMap::insert(witness)
    }
}