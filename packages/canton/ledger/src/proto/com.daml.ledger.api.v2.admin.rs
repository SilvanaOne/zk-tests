// This file is @generated by prost-build.
/// Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
///
/// Based on ``ObjectMeta`` meta used in Kubernetes API.
/// See <https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectMeta {
    /// An opaque, non-empty value, populated by a participant server which represents the internal version of the resource
    /// this ``ObjectMeta`` message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated.
    /// You must not rely on the format of resource version. The participant server might change it without notice.
    /// You can obtain the newest resource version value by issuing a read request.
    /// You may use it for concurrent change detection by passing it back unmodified in an update request.
    /// The participant server will then compare the passed value with the value maintained by the system to determine
    /// if any other updates took place since you had read the resource version.
    /// Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence.
    /// However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error.
    /// Concurrent change control is optional. It will be applied only if you include a resource version in an update request.
    /// When creating a new instance of a resource you must leave the resource version empty.
    /// Its value will be populated by the participant server upon successful resource creation.
    /// Optional
    #[prost(string, tag = "6")]
    pub resource_version: ::prost::alloc::string::String,
    /// A set of modifiable key-value pairs that can be used to represent arbitrary, client-specific metadata.
    /// Constraints:
    ///
    /// 1. The total size over all keys and values cannot exceed 256kb in UTF-8 encoding.
    /// 2. Keys are composed of an optional prefix segment and a required name segment such that:
    ///
    ///     - key prefix, when present, must be a valid DNS subdomain with at most 253 characters, followed by a '/' (forward slash) character,
    ///     - name segment must have at most 63 characters that are either alphanumeric (\[a-z0-9A-Z\]), or a '.' (dot), '-' (dash) or '_' (underscore);
    ///       and it must start and end with an alphanumeric character.
    ///
    /// 3. Values can be any non-empty strings.
    ///
    /// Keys with empty prefix are reserved for end-users.
    /// Properties set by external tools or internally by the participant server must use non-empty key prefixes.
    /// Duplicate keys are disallowed by the semantics of the protobuf3 maps.
    /// See: <https://developers.google.com/protocol-buffers/docs/proto3#maps>
    /// Annotations may be a part of a modifiable resource.
    /// Use the resource's update RPC to update its annotations.
    /// In order to add a new annotation or update an existing one using an update RPC, provide the desired annotation in the update request.
    /// In order to remove an annotation using an update RPC, provide the target annotation's key but set its value to the empty string in the update request.
    /// Optional
    /// Modifiable
    #[prost(map = "string, string", tag = "12")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Users are used to dynamically manage the rights given to Daml applications.
/// They are stored and managed per participant node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// The user identifier, which must be a non-empty string of at most 128
    /// characters that are either alphanumeric ASCII characters or one of the symbols "@^$.!`-#+'~_|:".
    /// Required
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The primary party as which this user reads and acts by default on the ledger
    /// *provided* it has the corresponding ``CanReadAs(primary_party)`` or
    /// ``CanActAs(primary_party)`` rights.
    /// Ledger API clients SHOULD set this field to a non-empty value for all users to
    /// enable the users to act on the ledger using their own Daml party.
    /// Users for participant administrators MAY have an associated primary party.
    /// Optional,
    /// Modifiable
    #[prost(string, tag = "2")]
    pub primary_party: ::prost::alloc::string::String,
    /// When set, then the user is denied all access to the Ledger API.
    /// Otherwise, the user has access to the Ledger API as per the user's rights.
    /// Optional,
    /// Modifiable
    #[prost(bool, tag = "3")]
    pub is_deactivated: bool,
    /// The metadata of this user.
    /// Note that the ``metadata.resource_version`` tracks changes to the properties described by the ``User`` message and not the user's rights.
    /// Optional,
    /// Modifiable
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ObjectMeta>,
    /// The ID of the identity provider configured by ``Identity Provider Config``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "5")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
/// A right granted to a user.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Right {
    /// Required
    #[prost(oneof = "right::Kind", tags = "1, 2, 3, 4, 5")]
    pub kind: ::core::option::Option<right::Kind>,
}
/// Nested message and enum types in `Right`.
pub mod right {
    /// The right to administer the participant node.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParticipantAdmin {}
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CanActAs {
        /// The right to authorize commands for this party.
        #[prost(string, tag = "1")]
        pub party: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CanReadAs {
        /// The right to read ledger data visible to this party.
        #[prost(string, tag = "1")]
        pub party: ::prost::alloc::string::String,
    }
    /// The right to administer the identity provider that the user is assigned to.
    /// It means, being able to manage users and parties that are also assigned
    /// to the same identity provider.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IdentityProviderAdmin {}
    /// The rights of a participant's super reader. Its utility is predominantly for
    /// feeding external tools, such as PQS, continually without the need to change subscriptions
    /// as new parties pop in and out of existence.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CanReadAsAnyParty {}
    /// Required
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// The user can administer the participant node.
        #[prost(message, tag = "1")]
        ParticipantAdmin(ParticipantAdmin),
        /// The user can act as a specific party.
        #[prost(message, tag = "2")]
        CanActAs(CanActAs),
        /// The user can read ledger data visible to a specific party.
        #[prost(message, tag = "3")]
        CanReadAs(CanReadAs),
        /// The user can administer users and parties assigned to the same identity provider as the one of the user.
        #[prost(message, tag = "4")]
        IdentityProviderAdmin(IdentityProviderAdmin),
        /// The user can read as any party on a participant
        #[prost(message, tag = "5")]
        CanReadAsAnyParty(CanReadAsAnyParty),
    }
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserRequest {
    /// The user to create.
    /// Required
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    /// The rights to be assigned to the user upon creation,
    /// which SHOULD include appropriate rights for the ``user.primary_party``.
    /// Optional
    #[prost(message, repeated, tag = "2")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserResponse {
    /// Created user.
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id) OR IsAuthenticatedUser(user_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserRequest {
    /// The user whose data to retrieve.
    /// If set to empty string (the default), then the data for the authenticated user will be retrieved.
    /// Optional
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUserResponse {
    /// Retrieved user.
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserRequest {
    /// The user to update.
    /// Required,
    /// Modifiable
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
    /// An update mask specifies how and which properties of the ``User`` message are to be updated.
    /// An update mask consists of a set of update paths.
    /// A valid update path points to a field or a subfield relative to the ``User`` message.
    /// A valid update mask must:
    ///
    /// 1. contain at least one update path,
    /// 2. contain only valid update paths.
    ///
    /// Fields that can be updated are marked as ``Modifiable``.
    /// An update path can also point to a non-``Modifiable`` fields such as 'id' and 'metadata.resource_version'
    /// because they are used:
    ///
    /// 1. to identify the user resource subject to the update,
    /// 2. for concurrent change control.
    ///
    /// Examples of valid update paths: 'primary_party', 'metadata', 'metadata.annotations'.
    /// For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
    /// For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest``.
    /// Required
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserResponse {
    /// Updated user
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<User>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserRequest {
    /// The user to delete.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
/// Does not (yet) contain any data.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserResponse {}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersRequest {
    /// Pagination token to determine the specific page to fetch.
    /// Leave empty to fetch the first page.
    /// Optional
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    /// Maximum number of results to be returned by the server. The server will return no more than that many results, but it might return fewer.
    /// If 0, the server will decide the number of results to be returned.
    /// Optional
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "4")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsersResponse {
    /// A subset of users of the participant node that fit into this page.
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
    /// Pagination token to retrieve the next page.
    /// Empty, if there are no further results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Add the rights to the set of rights granted to the user.
///
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantUserRightsRequest {
    /// The user to whom to grant rights.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The rights to grant.
    /// Optional
    #[prost(message, repeated, tag = "2")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "3")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrantUserRightsResponse {
    /// The rights that were newly granted by the request.
    #[prost(message, repeated, tag = "1")]
    pub newly_granted_rights: ::prost::alloc::vec::Vec<Right>,
}
/// Remove the rights from the set of rights granted to the user.
///
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeUserRightsRequest {
    /// The user from whom to revoke rights.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The rights to revoke.
    /// Optional
    #[prost(message, repeated, tag = "2")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "3")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeUserRightsResponse {
    /// The rights that were actually revoked by the request.
    #[prost(message, repeated, tag = "1")]
    pub newly_revoked_rights: ::prost::alloc::vec::Vec<Right>,
}
/// Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id) OR IsAuthenticatedUser(user_id)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUserRightsRequest {
    /// The user for which to list the rights.
    /// If set to empty string (the default), then the rights for the authenticated user will be listed.
    /// Required
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// The id of the ``Identity Provider``
    /// Optional, if not set, assume the user is managed by the default identity provider.
    #[prost(string, tag = "2")]
    pub identity_provider_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUserRightsResponse {
    /// All rights of the user.
    #[prost(message, repeated, tag = "1")]
    pub rights: ::prost::alloc::vec::Vec<Right>,
}
/// Required authorization: ``HasRight(ParticipantAdmin)``
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserIdentityProviderIdRequest {
    /// User to update
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// Current identity provider ID of the user
    #[prost(string, tag = "2")]
    pub source_identity_provider_id: ::prost::alloc::string::String,
    /// Target identity provider ID of the user
    #[prost(string, tag = "3")]
    pub target_identity_provider_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUserIdentityProviderIdResponse {}
/// Generated client implementations.
pub mod user_management_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage users and their rights for interacting with the Ledger API
    /// served by a participant node.
    ///
    /// The authorization rules for its RPCs are specified on the ``<RpcName>Request``
    /// messages as boolean expressions over these facts:
    ///
    /// 1. ``HasRight(r)`` denoting whether the authenticated user has right ``r`` and
    /// 2. ``IsAuthenticatedUser(uid)`` denoting whether ``uid`` is the empty string or equal to the id of the authenticated user.
    /// 3. ``IsAuthenticatedIdentityProviderAdmin(idp)`` denoting whether ``idp`` is equal to the ``identity_provider_id``
    ///    of the authenticated user and the user has an IdentityProviderAdmin right.
    ///
    /// If `user_id` is set to the empty string (the default), then the data for the authenticated user will be retrieved.
    /// If `identity_provider_id` is set to an empty string, then it's effectively set to the value of access token's 'iss' field if that is provided.
    /// If `identity_provider_id` remains an empty string, the default identity provider will be assumed.
    ///
    /// The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
    ///
    /// 1. ``Optional`` denoting the client may leave the field unset when sending a request.
    /// 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
    ///
    /// A user resource consists of:
    ///
    /// 1. a set of properties represented by the ``User`` message,
    /// 2. a set of user rights, where each right is represented by the ``Right`` message.
    ///
    /// A user resource, once it has been created, can be modified.
    /// In order to update the properties represented by the ``User`` message use the ``UpdateUser`` RPC. The only fields that can be modified are those marked as ``Modifiable``.
    /// In order to grant or revoke user rights use ``GrantRights' and ``RevokeRights`` RPCs.
    #[derive(Debug, Clone)]
    pub struct UserManagementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserManagementServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserManagementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserManagementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UserManagementServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new user.
        pub async fn create_user(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/CreateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "CreateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the user data of a specific user or the authenticated user.
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "GetUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update selected modifiable attribute of a user resource described by the ``User`` message.
        pub async fn update_user(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/UpdateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "UpdateUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete an existing user and all its rights.
        pub async fn delete_user(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/DeleteUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "DeleteUser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all existing users.
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/ListUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "ListUsers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Grant rights to a user.
        /// Granting rights does not affect the resource version of the corresponding user.
        pub async fn grant_user_rights(
            &mut self,
            request: impl tonic::IntoRequest<super::GrantUserRightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GrantUserRightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/GrantUserRights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "GrantUserRights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Revoke rights from a user.
        /// Revoking rights does not affect the resource version of the corresponding user.
        pub async fn revoke_user_rights(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeUserRightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeUserRightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/RevokeUserRights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "RevokeUserRights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List the set of all rights granted to a user.
        pub async fn list_user_rights(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUserRightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUserRightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/ListUserRights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "ListUserRights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the assignment of a user from one IDP to another.
        pub async fn update_user_identity_provider_id(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUserIdentityProviderIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateUserIdentityProviderIdResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/com.daml.ledger.api.v2.admin.UserManagementService/UpdateUserIdentityProviderId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "com.daml.ledger.api.v2.admin.UserManagementService",
                        "UpdateUserIdentityProviderId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
