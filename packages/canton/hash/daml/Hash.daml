module Hash where

import DA.Crypto.Text (keccak256)
import qualified DA.Crypto.Text as Crypto
import Silvana

type HashId = ContractId Hash

-- Helper function for iterative hashing (for Sha256n choice)
-- Recursively hashes: hash_i+1 = sha256(hash_i <> args)
hashNTimes : Int -> Text -> Text -> Text
hashNTimes 0 currentHash _ = currentHash
hashNTimes n currentHash args =
    let nextHash = Crypto.sha256 (currentHash <> args)
    in hashNTimes (n - 1) nextHash args

template Hash
  with
    owner : Party
    provider : Party   -- Provider party (maintainer of contract key)
    id : Text          -- Unique identifier for this Hash contract
    add_result : Int
    keccak_result : Optional Text
    sha256_result : Optional Text
    root : Text        -- hex-encoded merkle map root
    root_time : Optional Time   -- timestamp when root was last updated
  where
    signatory owner
    observer provider

    -- Hash-specific choices (not related to IndexedMerkleMap)
    choice Add : HashId
      with
        numbers : [Int]
      controller owner
      do create this with
           add_result = sum numbers

    choice Keccak : HashId
      with
        hexStrings : [Text]
      controller owner
      do
        let concatenated = mconcat hexStrings
        let hash = keccak256 concatenated
        create this with
          keccak_result = Some hash

    choice Sha256 : HashId
      with
        hexStrings : [Text]
      controller owner
      do
        let concatenated = mconcat hexStrings
        let hash = Crypto.sha256 concatenated
        create this with
          sha256_result = Some hash

    choice Sha256n : HashId
      with
        hexStrings : [Text]
        count : Int
      controller owner
      do
        -- Iteratively hash n times
        -- hash1 = sha256(hexStrings)
        -- hash2 = sha256(hash1 <> hexStrings)
        -- ... n times
        let concatenated = mconcat hexStrings
            initialHash = Crypto.sha256 concatenated
            finalHash = if count <= 1
                        then initialHash
                        else hashNTimes (count - 1) initialHash concatenated
        create this with
          sha256_result = Some finalHash

    -- Implement IndexedMerkleMap interface
    interface instance IndexedMerkleMap for Hash where
      view = IndexedMerkleMapView with
        owner
        provider
        id
        root
        rootTime = root_time

      getOwner = owner
      getRoot = root
      getRootTime = root_time

      addMapElementImpl witness = do
        currentTime <- getTime
        assertMsg "Old root does not match current state" (witness.oldRoot == root)
        assertMsg "Insert witness verification failed" (verifyInsertWitness witness)
        cid <- create this with
          root = witness.newRoot
          root_time = Some currentTime
        return (toInterfaceContractId @IndexedMerkleMap cid)

      updateMapElementImpl witness = do
        currentTime <- getTime
        assertMsg "Old root does not match current state" (witness.oldRoot == root)
        assertMsg "Update witness verification failed" (verifyUpdateWitness witness)
        cid <- create this with
          root = witness.newRoot
          root_time = Some currentTime
        return (toInterfaceContractId @IndexedMerkleMap cid)

      verifyInclusionImpl proof = do
        assertMsg "Proof root does not match current state" (proof.root == root)
        let isValid = verifyMembershipProof proof
        assertMsg "Membership proof verification failed" isValid
        return isValid

      verifyExclusionImpl proof = do
        assertMsg "Proof root does not match current state" (proof.root == root)
        let isValid = verifyNonMembershipProof proof
        assertMsg "Non-membership proof verification failed" isValid
        return isValid
