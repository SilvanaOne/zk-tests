module Hash where

import DA.Crypto.Text (keccak256, toHex)
import qualified DA.Crypto.Text as Crypto
import qualified DA.Text as T
import DA.List (foldl)

type HashId = ContractId Hash

-- Data structures for IndexedMerkleMap witness verification

data Leaf = Leaf with
    key : Text        -- hex-encoded Field (32 bytes, 64 hex chars)
    value : Text      -- hex-encoded Field (32 bytes, 64 hex chars)
    nextKey : Text    -- hex-encoded Field (32 bytes, 64 hex chars)
    index : Int
  deriving (Eq, Show)

data MerkleProof = MerkleProof with
    siblings : [Text]      -- list of hex-encoded hashes (32 bytes each)
    pathIndices : [Bool]   -- true = right, false = left
  deriving (Eq, Show)

data InsertWitness = InsertWitness with
    oldRoot : Text
    newRoot : Text
    key : Text
    value : Text
    newLeafIndex : Int
    treeLength : Int
    lowLeaf : Leaf
    lowLeafProof : MerkleProof
    updatedLowLeaf : Leaf
    newLeaf : Leaf
    newLeafProofAfter : MerkleProof
  deriving (Eq, Show)

-- Helper functions for SHA256 verification

-- Convert a single digit to hex character
toHexDigit : Int -> Text
toHexDigit d =
    if d < 10 then show d
    else if d == 10 then "a"
    else if d == 11 then "b"
    else if d == 12 then "c"
    else if d == 13 then "d"
    else if d == 14 then "e"
    else "f"

-- Recursively convert integer to hex string
toHexRec : Int -> Text -> Text
toHexRec 0 acc = if T.length acc == 0 then "0" else acc
toHexRec num acc =
    let remainder = num % 16
        quotient = num / 16
    in toHexRec quotient (toHexDigit remainder <> acc)

-- Convert Int to 8-byte big-endian hex string (16 hex chars)
-- Pads with zeros on the left to ensure 16 hex chars (8 bytes)
intToHex8Bytes : Int -> Text
intToHex8Bytes n =
    let hexText = toHexRec n ""
        hexLen = T.length hexText
        -- Pad with zeros to get exactly 16 characters (8 bytes)
        zerosNeeded = 16 - hexLen
        padding = if zerosNeeded <= 0 then ""
                  else T.take zerosNeeded "0000000000000000"
    in padding <> hexText

-- Hash a leaf: sha256(key || value || next_key)
hashLeaf : Leaf -> Text
hashLeaf leaf =
    Crypto.sha256 (leaf.key <> leaf.value <> leaf.nextKey)

-- Hash two hashes together: sha256(left || right)
hashPair : Text -> Text -> Text
hashPair left right =
    Crypto.sha256 (left <> right)

-- Compute merkle root from leaf hash and proof
computeRoot : Text -> MerkleProof -> Text
computeRoot leafHash proof =
    foldl (\current (sibling, isRight) ->
        if isRight
        then hashPair sibling current  -- current is right child
        else hashPair current sibling  -- current is left child
    ) leafHash (zip proof.siblings proof.pathIndices)

-- Combine internal root with length to create final root
combineRootWithLength : Text -> Int -> Text
combineRootWithLength internalRoot length =
    let lengthHex = intToHex8Bytes length
    in Crypto.sha256 (internalRoot <> lengthHex)

-- Convert path indices (bits) to leaf index
-- Uses iterative doubling instead of power operations for efficiency
-- Simulates bit shifting: result |= (bit << position)
pathIndicesToIndex : [Bool] -> Int
pathIndicesToIndex bits =
    let -- Process bits with position and power-of-2 value computed iteratively
        addBit (idx, powerOf2) isRight =
            let newIdx = if isRight then idx + powerOf2 else idx
                newPower = powerOf2 * 2
            in (newIdx, newPower)
        (finalIdx, _) = foldl addBit (0, 1) bits
    in finalIdx

-- Compare two hex-encoded Field values (32 bytes)
-- Returns: LT if a < b, EQ if a == b, GT if a > b
compareFields : Text -> Text -> Ordering
compareFields a b = compare a b

-- Check if field is zero (all zeros)
isZeroField : Text -> Bool
isZeroField field = field == "0000000000000000000000000000000000000000000000000000000000000000"

-- Helper function to check all characters in a hex string are valid
checkAllHexChars : Text -> Int -> Int -> Bool
checkAllHexChars hexStr i len =
    if i >= len then True
    else
        let char = T.take 1 (T.drop i hexStr)
        in (char >= "0" && char <= "9" || char >= "a" && char <= "f") && checkAllHexChars hexStr (i + 1) len

-- Validate hex string is exactly 64 lowercase hex characters (32 bytes)
isValidHex32 : Text -> Bool
isValidHex32 hexStr =
    let len = T.length hexStr
    in len == 64 && checkAllHexChars hexStr 0 len

-- Helper function for iterative hashing (for Sha256n choice)
-- Recursively hashes: hash_i+1 = sha256(hash_i <> args)
hashNTimes : Int -> Text -> Text -> Text
hashNTimes 0 currentHash _ = currentHash
hashNTimes n currentHash args =
    let nextHash = Crypto.sha256 (currentHash <> args)
    in hashNTimes (n - 1) nextHash args

-- Find the level where two merkle paths diverge (Lowest Common Ancestor)
-- Returns the level index where paths first differ
findLCALevelRec : [Bool] -> [Bool] -> Int -> Int
findLCALevelRec [] [] level = level
findLCALevelRec (p1::rest1) (p2::rest2) level =
    if p1 == p2
    then findLCALevelRec rest1 rest2 (level + 1)
    else level
findLCALevelRec _ _ level = level

findLCALevel : [Bool] -> [Bool] -> Int
findLCALevel path1 path2 = findLCALevelRec path1 path2 0

-- Get nth element from a list (0-indexed), returns zero hash if out of bounds
getNth : Int -> [Text] -> Text
getNth 0 (x::_) = x
getNth n (_::xs) = getNth (n - 1) xs
getNth _ [] = "0000000000000000000000000000000000000000000000000000000000000000"

-- Hash from a leaf up the tree to a specific level
-- Used for LCA anchor check
hashUpToLevelRec : Text -> [Text] -> [Bool] -> Int -> Int -> Text
hashUpToLevelRec currentHash _ _ level targetLevel | level >= targetLevel = currentHash
hashUpToLevelRec currentHash (sib::sibs) (isRight::paths) level targetLevel =
    let nextHash = if isRight
                   then hashPair sib currentHash  -- current is right child
                   else hashPair currentHash sib  -- current is left child
    in hashUpToLevelRec nextHash sibs paths (level + 1) targetLevel
hashUpToLevelRec currentHash _ _ _ _ = currentHash

hashUpToLevel : Text -> [Text] -> [Bool] -> Int -> Text
hashUpToLevel leafHash siblings pathIndices targetLevel =
    hashUpToLevelRec leafHash siblings pathIndices 0 targetLevel

-- Verify insert witness (implements all 8 constraints from ProvableIndexedMerkleMap::insert)
verifyInsertWitness : InsertWitness -> Bool
verifyInsertWitness witness =
    -- HEX FORMAT VALIDATION: Ensure all fields are valid 32-byte hex strings
    let hexFieldsValid =
            isValidHex32 witness.oldRoot &&
            isValidHex32 witness.newRoot &&
            isValidHex32 witness.key &&
            isValidHex32 witness.value &&
            isValidHex32 witness.lowLeaf.key &&
            isValidHex32 witness.lowLeaf.value &&
            isValidHex32 witness.lowLeaf.nextKey &&
            isValidHex32 witness.updatedLowLeaf.key &&
            isValidHex32 witness.updatedLowLeaf.value &&
            isValidHex32 witness.updatedLowLeaf.nextKey &&
            isValidHex32 witness.newLeaf.key &&
            isValidHex32 witness.newLeaf.value &&
            isValidHex32 witness.newLeaf.nextKey &&
            all isValidHex32 witness.lowLeafProof.siblings &&
            all isValidHex32 witness.newLeafProofAfter.siblings

    -- SANITY CHECKS: Validate proof structure
        lowProofSiblingsLen = length witness.lowLeafProof.siblings
        lowProofIndicesLen = length witness.lowLeafProof.pathIndices
        newProofSiblingsLen = length witness.newLeafProofAfter.siblings
        newProofIndicesLen = length witness.newLeafProofAfter.pathIndices

        -- Check proof lengths match
        proofLengthCheck =
            lowProofSiblingsLen == lowProofIndicesLen &&
            newProofSiblingsLen == newProofIndicesLen

        -- FIXED HEIGHT CHECK: Enforce exactly 31 siblings (height 32 tree = 31 proof levels)
        -- Rust implementation always generates exactly 31 siblings for all proofs
        proofBoundsCheck =
            lowProofSiblingsLen == 31 &&
            newProofSiblingsLen == 31

        -- TREE CAPACITY CHECK: Verify tree can hold the claimed number of leaves
        -- Height 31 proofs can hold up to 2^31 = 2,147,483,648 leaves
        treeCapacityCheck =
            witness.treeLength > 0 &&
            witness.treeLength <= 2147483648 &&
            witness.treeLength + 1 <= 2147483648

        -- Compute indices once for reuse
        lowIdx = pathIndicesToIndex witness.lowLeafProof.pathIndices
        newIdx = pathIndicesToIndex witness.newLeafProofAfter.pathIndices

        -- Index bounds checks
        indexBoundsCheck =
            witness.treeLength >= 1 &&  -- Tree must have at least sentinel leaf
            lowIdx >= 0 && lowIdx < witness.treeLength &&  -- Low leaf must be within tree
            witness.newLeafIndex >= 0 &&  -- New leaf index must be non-negative
            witness.newLeafIndex == witness.treeLength  -- Must be append-only

    -- CONSTRAINT 1: Verify append-only (new leaf index must equal tree length)
        appendOnlyCheck = witness.newLeafIndex == witness.treeLength

    -- CONSTRAINT 2: Verify path-index consistency
        pathConsistencyCheck = lowIdx == witness.lowLeaf.index && newIdx == witness.newLeafIndex

    -- CONSTRAINT 3: Verify non-membership (key doesn't exist in old tree)
        lowLeafHash = hashLeaf witness.lowLeaf
        lowLeafInternalRoot = computeRoot lowLeafHash witness.lowLeafProof
        lowLeafRoot = combineRootWithLength lowLeafInternalRoot witness.treeLength
        nonMembershipProofCheck = lowLeafRoot == witness.oldRoot

    -- CONSTRAINT 4: Verify key ordering (low_leaf.key < new_key < low_leaf.next_key)
        keyOrderingCheck =
            compareFields witness.lowLeaf.key witness.key == LT &&
            (isZeroField witness.lowLeaf.nextKey || compareFields witness.key witness.lowLeaf.nextKey == LT)

    -- CONSTRAINT 5: Verify updated low leaf structure
        updatedLowLeafCheck =
            witness.updatedLowLeaf.key == witness.lowLeaf.key &&
            witness.updatedLowLeaf.value == witness.lowLeaf.value &&
            witness.updatedLowLeaf.index == witness.lowLeaf.index &&
            witness.updatedLowLeaf.nextKey == witness.key

    -- CONSTRAINT 6: Verify new leaf structure
        newLeafCheck =
            witness.newLeaf.key == witness.key &&
            witness.newLeaf.value == witness.value &&
            witness.newLeaf.nextKey == witness.lowLeaf.nextKey &&
            witness.newLeaf.index == witness.newLeafIndex

    -- CONSTRAINT 7 & 8: Verify final root computation
        newLeafHash = hashLeaf witness.newLeaf
        newLeafInternalRoot = computeRoot newLeafHash witness.newLeafProofAfter
        computedNewRoot = combineRootWithLength newLeafInternalRoot (witness.treeLength + 1)
        finalRootCheck = computedNewRoot == witness.newRoot

    -- LCA ANCHOR CHECK (Defense-in-depth): Link updatedLowLeaf path to newLeafProofAfter
    -- Prevents using unrelated proofs from different trees
        lcaLevel = findLCALevel witness.lowLeafProof.pathIndices witness.newLeafProofAfter.pathIndices

        -- Hash updatedLowLeaf up to the LCA level along the low leaf path
        anchorFromUpdatedLowLeaf = hashUpToLevel
            (hashLeaf witness.updatedLowLeaf)
            witness.lowLeafProof.siblings
            witness.lowLeafProof.pathIndices
            lcaLevel

        -- Extract sibling at LCA level from new leaf proof
        expectedSiblingAtLCA = getNth lcaLevel witness.newLeafProofAfter.siblings

        -- Verify anchor matches sibling at LCA (only if paths diverge before root)
        lcaAnchorCheck =
            if lcaLevel < 31  -- Paths diverge before reaching root
            then anchorFromUpdatedLowLeaf == expectedSiblingAtLCA
            else True  -- Paths identical (shouldn't happen in practice, but allow it)

    in hexFieldsValid && proofLengthCheck && proofBoundsCheck && treeCapacityCheck && indexBoundsCheck &&
       appendOnlyCheck && pathConsistencyCheck && nonMembershipProofCheck &&
       keyOrderingCheck && updatedLowLeafCheck && newLeafCheck && finalRootCheck && lcaAnchorCheck

template Hash
  with
    owner : Party
    add_result : Int
    keccak_result : Optional Text
    sha256_result : Optional Text
    root : Optional Text  -- hex-encoded merkle map root
  where
    signatory owner
    choice Add : HashId
      with
        numbers : [Int]
      controller owner
      do create this with
           add_result = sum numbers

    choice Keccak : HashId
      with
        hexStrings : [Text]
      controller owner
      do
        let concatenated = mconcat hexStrings
        let hash = keccak256 concatenated
        create this with
          keccak_result = Some hash

    choice Sha256 : HashId
      with
        hexStrings : [Text]
      controller owner
      do
        let concatenated = mconcat hexStrings
        let hash = Crypto.sha256 concatenated
        create this with
          sha256_result = Some hash

    choice Sha256n : HashId
      with
        hexStrings : [Text]
        count : Int
      controller owner
      do
        -- Iteratively hash n times
        -- hash1 = sha256(hexStrings)
        -- hash2 = sha256(hash1 <> hexStrings)
        -- ... n times
        let concatenated = mconcat hexStrings
            initialHash = Crypto.sha256 concatenated
            finalHash = if count <= 1
                        then initialHash
                        else hashNTimes (count - 1) initialHash concatenated
        create this with
          sha256_result = Some finalHash

    choice AddMapElement : HashId
      with
        witness : InsertWitness
      controller owner
      do
        -- Verify old root matches current state
        let currentRoot = case this.root of
              Some r -> r
              None -> error "Root not initialized"

        -- Check old root matches
        assertMsg "Old root does not match current state" (witness.oldRoot == currentRoot)

        -- Cryptographically verify the insert witness
        assertMsg "Insert witness verification failed" (verifyInsertWitness witness)

        -- Update state with new root
        create this with
          root = Some witness.newRoot
