-- Copyright (c) 2025 Silvana. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Production-ready token implementation following Canton Token Standard (CIP-56).
--
-- This module implements a complete CIP-56 compliant token with:
-- - Holding interface for balance representation
-- - TransferFactory + TransferInstruction for P2P transfers
-- - BurnMintFactory for issuance and redemption
module TestToken where

import Splice.Api.Token.MetadataV1 qualified as Token.Metadata
import Splice.Api.Token.HoldingV1 qualified as Token.Holding
import Splice.Api.Token.TransferInstructionV1 qualified as Token.Transfer
import Splice.Api.Token.BurnMintV1 qualified as Token.BurnMint
import DA.TextMap qualified as TextMap
import DA.Foldable (forA_)

----------------------------------------------------------------------------------------------------
-- Holding Template
----------------------------------------------------------------------------------------------------

-- | A CIP-56 compliant token holding.
template TestToken
  with
    owner : Party
      -- ^ The party that owns this token holding.
    instrumentAdmin : Party
      -- ^ The registry/admin party administering this instrument (per CIP-56).
    amount : Decimal
      -- ^ The amount of tokens in this holding.
    instrumentId : Text
      -- ^ The identifier for this token instrument.
    metadata : TextMap.TextMap Text
      -- ^ Additional metadata for this holding.
  where
    signatory owner, instrumentAdmin

    ensure amount > 0.0

    -- Implement the Holding interface for CIP-56 compliance
    interface instance Token.Holding.Holding for TestToken where
      view = Token.Holding.HoldingView with
        owner
        instrumentId = Token.Holding.InstrumentId with
          admin = instrumentAdmin
          id = instrumentId
        amount
        lock = None
        meta = Token.Metadata.Metadata with values = metadata

----------------------------------------------------------------------------------------------------
-- Transfer Factory
----------------------------------------------------------------------------------------------------

-- | Factory for creating transfer instructions between parties.
template TestTokenTransferFactory
  with
    admin : Party
      -- ^ The registry admin party.
  where
    signatory admin

    interface instance Token.Transfer.TransferFactory for TestTokenTransferFactory where
      view = Token.Transfer.TransferFactoryView with
        admin
        meta = Token.Metadata.emptyMetadata

      transferFactory_transferImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)

        let transfer = arg.transfer
        let instrId = transfer.instrumentId

        -- Validate instrument admin matches factory admin
        assertMsg "Instrument admin must match factory admin" (instrId.admin == admin)

        -- Validate executeBefore is in the future
        now <- getTime
        assertMsg "executeBefore must be in the future" (transfer.executeBefore > now)
        assertMsg "requestedAt must be in the past" (transfer.requestedAt <= now)

        -- Create transfer instruction in pending receiver acceptance state
        instrCid <- create TestTokenTransferInstruction with
          transfer
          status = Token.Transfer.TransferPendingReceiverAcceptance
          originalInstructionCid = None

        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Pending with
            transferInstructionCid = toInterfaceContractId @Token.Transfer.TransferInstruction instrCid
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.Transfer.TransferFactoryView with
          admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Transfer Instruction
----------------------------------------------------------------------------------------------------

-- | A transfer instruction tracking the state of a P2P transfer.
template TestTokenTransferInstruction
  with
    transfer : Token.Transfer.Transfer
      -- ^ The transfer specification.
    status : Token.Transfer.TransferInstructionStatus
      -- ^ Current status of the transfer.
    originalInstructionCid : Optional (ContractId Token.Transfer.TransferInstruction)
      -- ^ Original instruction CID for tracking lineage.
  where
    signatory transfer.sender
    observer transfer.receiver, transfer.instrumentId.admin

    interface instance Token.Transfer.TransferInstruction for TestTokenTransferInstruction where
      view = Token.Transfer.TransferInstructionView with
        transfer
        status
        originalInstructionCid
        meta = Token.Metadata.emptyMetadata

      transferInstruction_acceptImpl self arg = do
        -- Can only accept if pending receiver acceptance
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> pure ()
          _ -> abort "Transfer is not pending receiver acceptance"

        -- Archive input holdings and calculate amounts
        totalInput <- archiveAndSumHoldings transfer.inputHoldingCids

        -- Validate sufficient funds
        assertMsg "Insufficient funds in input holdings" (totalInput >= transfer.amount)

        -- Create receiver holding
        receiverCid <- create TestToken with
          owner = transfer.receiver
          instrumentAdmin = transfer.instrumentId.admin
          amount = transfer.amount
          instrumentId = transfer.instrumentId.id
          metadata = transfer.meta.values

        -- Create sender change if needed
        changeCids <- if totalInput > transfer.amount
          then do
            changeCid <- create TestToken with
              owner = transfer.sender
              instrumentAdmin = transfer.instrumentId.admin
              amount = totalInput - transfer.amount
              instrumentId = transfer.instrumentId.id
              metadata = transfer.meta.values
            return [toInterfaceContractId @Token.Holding.Holding changeCid]
          else return []

        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Completed with
            receiverHoldingCids = [toInterfaceContractId @Token.Holding.Holding receiverCid]
          senderChangeCids = changeCids
          meta = Token.Metadata.emptyMetadata

      transferInstruction_rejectImpl self arg = do
        -- Can only reject if pending receiver acceptance
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> pure ()
          _ -> abort "Transfer is not pending receiver acceptance"

        -- Return holdings to sender (no-op for this simple implementation)
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferInstruction_withdrawImpl self arg = do
        -- Sender can always withdraw
        -- Return holdings to sender (no-op for this simple implementation)
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferInstruction_updateImpl self arg = do
        -- Admin can update the transfer state
        -- For this simple implementation, we don't support internal workflows
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Pending with
            transferInstructionCid = toInterfaceContractId @Token.Transfer.TransferInstruction self
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Mint Request (Propose-Accept Pattern)
----------------------------------------------------------------------------------------------------

-- | A mint request following the propose-accept pattern.
-- This allows the admin to propose minting tokens to a receiver,
-- who must explicitly accept to receive the tokens.
template TestTokenMintRequest
  with
    admin : Party
      -- ^ The admin proposing the mint.
    receiver : Party
      -- ^ The party who will receive the tokens if they accept.
    amount : Decimal
      -- ^ The amount of tokens to mint.
    instrumentId : Text
      -- ^ The instrument ID for the token.
    metadata : TextMap.TextMap Text
      -- ^ Metadata for the minted token.
  where
    signatory admin
    observer receiver

    ensure amount > 0.0

    choice Accept : ContractId TestToken
      -- ^ Accept the mint request and create the token.
      controller receiver
      do
        create TestToken with
          owner = receiver
          instrumentAdmin = admin
          amount
          instrumentId
          metadata

    choice Reject : ()
      -- ^ Reject the mint request.
      controller receiver
      do
        pure ()

    choice Withdraw : ()
      -- ^ Withdraw the mint request.
      controller admin
      do
        pure ()

----------------------------------------------------------------------------------------------------
-- Burn/Mint Factory
----------------------------------------------------------------------------------------------------

-- | Factory for burn and mint operations.
template TestTokenBurnMintFactory
  with
    admin : Party
      -- ^ The registry admin party.
    instrumentId : Text
      -- ^ The instrument ID for this factory.
  where
    signatory admin

    -- Propose mint using propose-accept pattern (only requires admin authorization)
    nonconsuming choice ProposeMint : ContractId TestTokenMintRequest
      with
        receiver : Party
        amount : Decimal
      controller admin
      do
        create TestTokenMintRequest with
          admin
          receiver
          amount
          instrumentId
          metadata = TextMap.fromList
            [ ("example.com/instrument-id", instrumentId)
            , ("example.com/symbol", "TEST")
            , ("example.com/name", "Test Token")
            , ("example.com/decimals", "10")
            ]

    -- Template choice wrapper for HTTP API compatibility (direct mint, requires receiver authorization)
    nonconsuming choice Mint : Token.BurnMint.BurnMintFactory_BurnMintResult
      with
        receiver : Party
        amount : Decimal
        extraActors : [Party]
      controller admin, receiver :: extraActors
      do
        let interfaceCid = toInterfaceContractId @Token.BurnMint.BurnMintFactory self
        exercise interfaceCid Token.BurnMint.BurnMintFactory_BurnMint with
          expectedAdmin = admin
          instrumentId = Token.Holding.InstrumentId with
            admin
            id = instrumentId
          inputHoldingCids = []
          outputs = [Token.BurnMint.BurnMintOutput with
            owner = receiver
            amount = amount
            context = Token.Metadata.ChoiceContext with values = TextMap.empty]
          extraActors = extraActors
          extraArgs = Token.Metadata.ExtraArgs with
            context = Token.Metadata.ChoiceContext with values = TextMap.empty
            meta = Token.Metadata.emptyMetadata

    interface instance Token.BurnMint.BurnMintFactory for TestTokenBurnMintFactory where
      view = Token.BurnMint.BurnMintFactoryView with
        admin
        meta = Token.Metadata.emptyMetadata

      burnMintFactory_burnMintImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        assertMsg "Instrument admin mismatch" (arg.instrumentId.admin == admin)
        assertMsg "Instrument ID mismatch" (arg.instrumentId.id == instrumentId)

        -- Archive all input holdings
        forA_ arg.inputHoldingCids (\cid -> archive cid)

        -- Create output holdings
        outputCids <- mapA (\output -> do
          cid <- create TestToken with
            owner = output.owner
            instrumentAdmin = admin
            amount = output.amount
            instrumentId = instrumentId
            metadata = TextMap.fromList
              [ ("example.com/instrument-id", instrumentId)
              , ("example.com/symbol", "TEST")
              , ("example.com/name", "Test Token")
              , ("example.com/decimals", "10")
              ]
          return (toInterfaceContractId @Token.Holding.Holding cid)
          ) arg.outputs

        return Token.BurnMint.BurnMintFactory_BurnMintResult with
          outputCids

      burnMintFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.BurnMint.BurnMintFactoryView with
          admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Helper Functions
----------------------------------------------------------------------------------------------------

-- | Archive holdings and return the total amount.
archiveAndSumHoldings : [ContractId Token.Holding.Holding] -> Update Decimal
archiveAndSumHoldings cids = do
  amounts <- mapA (\cid -> do
      holding <- fetch cid
      let holdingView = view holding
      archive cid
      return holdingView.amount
    ) cids
  return (sum amounts)
