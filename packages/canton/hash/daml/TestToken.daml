-- Copyright (c) 2025 Silvana. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Production-ready token implementation following Canton Token Standard (CIP-56).
--
-- This module implements a complete CIP-56 compliant token with:
-- - Holding interface for balance representation
-- - TransferFactory + TransferInstruction for P2P transfers
-- - BurnMintFactory for issuance and redemption
module TestToken where

import Splice.Api.Token.MetadataV1 qualified as Token.Metadata
import Splice.Api.Token.HoldingV1 qualified as Token.Holding
import Splice.Api.Token.TransferInstructionV1 qualified as Token.Transfer
import Splice.Api.Token.BurnMintV1 qualified as Token.BurnMint
import DA.TextMap qualified as TextMap
import DA.Foldable (forA_)
import DA.Time (RelTime)

----------------------------------------------------------------------------------------------------
-- Holding Template
----------------------------------------------------------------------------------------------------

-- | A CIP-56 compliant token holding.
template TestToken
  with
    owner : Party
      -- ^ The party that owns this token holding.
    instrumentAdmin : Party
      -- ^ The registry/admin party administering this instrument (per CIP-56).
    amount : Decimal
      -- ^ The amount of tokens in this holding.
    instrumentId : Text
      -- ^ The identifier for this token instrument.
    lock : Optional Token.Holding.Lock
      -- ^ Optional lock on this holding (for DVP, escrow, etc.).
    metadata : TextMap.TextMap Text
      -- ^ Additional metadata for this holding.
  where
    signatory owner, instrumentAdmin
    observer (optional [] (\l -> l.holders) lock)
      -- ^ Lock holders are observers to enable them to see locked holdings

    ensure amount > 0.0

    -- Implement the Holding interface for CIP-56 compliance
    interface instance Token.Holding.Holding for TestToken where
      view = Token.Holding.HoldingView with
        owner
        instrumentId = Token.Holding.InstrumentId with
          admin = instrumentAdmin
          id = instrumentId
        amount
        lock = lock
        meta = Token.Metadata.Metadata with values = metadata

    -- Lock management choices

    -- | Lock this holding with the specified lock parameters.
    choice LockHolding : ContractId TestToken
      with
        newLock : Token.Holding.Lock
      controller owner
      do
        -- Validate lock parameters
        assertMsg "Lock must have at least one holder" (not $ null newLock.holders)
        create this with lock = Some newLock

    -- | Unlock this holding if the lock has expired or if authorized.
    choice UnlockHolding : ContractId TestToken
      controller owner
      do
        case lock of
          None -> error "No lock to unlock"
          Some currentLock -> do
            -- Check if lock is expired
            now <- getTime
            let expiryTime = case (currentLock.expiresAt, currentLock.expiresAfter) of
                  (Some absTime, None) -> absTime
                  (None, Some _) -> error "Relative expiry not yet supported in unlock"
                  (Some absTime, Some _) -> absTime  -- Use absolute time if both set
                  (None, None) -> error "Lock has no expiry"

            assertMsg "Lock has not expired yet" (now >= expiryTime)
            create this with lock = None

    -- | Update lock parameters (requires authorization from current lock holders).
    choice UpdateLock : ContractId TestToken
      with
        updatedLock : Token.Holding.Lock
        authorizer : Party
      controller authorizer
      do
        case lock of
          None -> error "No lock to update"
          Some currentLock -> do
            assertMsg "Authorizer must be a current lock holder"
              (authorizer `elem` currentLock.holders)
            create this with lock = Some updatedLock

----------------------------------------------------------------------------------------------------
-- Transfer Factory
----------------------------------------------------------------------------------------------------

-- | Factory for creating transfer instructions between parties.
template TestTokenTransferFactory
  with
    admin : Party
      -- ^ The registry admin party.
  where
    signatory admin

    interface instance Token.Transfer.TransferFactory for TestTokenTransferFactory where
      view = Token.Transfer.TransferFactoryView with
        admin
        meta = Token.Metadata.emptyMetadata

      transferFactory_transferImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)

        let transfer = arg.transfer
        let instrId = transfer.instrumentId

        -- Validate instrument admin matches factory admin
        assertMsg "Instrument admin must match factory admin" (instrId.admin == admin)

        -- Validate executeBefore is in the future
        now <- getTime
        assertMsg "executeBefore must be in the future" (transfer.executeBefore > now)
        assertMsg "requestedAt must be in the past" (transfer.requestedAt <= now)

        -- Handle input holdings if provided (enables contention-based duplicate prevention)
        changeCids <- if null transfer.inputHoldingCids
          then
            -- Empty list: automatic selection mode (holdings will be selected at Accept time)
            return []
          else do
            -- Provided list: explicit UTXO selection mode
            -- Fetch and validate all input holdings as interface contracts
            holdingViews <- mapA (\cid -> do
              holding <- fetch (coerceContractId @Token.Holding.Holding cid)
              return (view (holding : Token.Holding.Holding))
              ) transfer.inputHoldingCids

            -- Validate each holding
            forA_ holdingViews $ \holdingView -> do
              assertMsg "Input holding owner must be sender"
                (holdingView.owner == transfer.sender)
              assertMsg "Input holding instrument mismatch"
                (holdingView.instrumentId == transfer.instrumentId)

              -- Validate lock status
              case holdingView.lock of
                None -> pure ()
                Some lockInfo -> do
                  let isExpired = case (lockInfo.expiresAt, lockInfo.expiresAfter) of
                        (Some absTime, _) -> now >= absTime
                        (_, _) -> False
                  assertMsg ("Cannot use locked holding in transfer. Context: " <> optional "" (\c -> c) lockInfo.context)
                    isExpired

            -- Calculate total input
            let totalInput = sum $ map (\v -> v.amount) holdingViews

            -- Validate sufficient funds
            assertMsg "Insufficient input holdings for transfer amount"
              (totalInput >= transfer.amount)

            -- Archive input holdings (creates deliberate contention)
            forA_ transfer.inputHoldingCids archive

            -- Create change holding if needed
            if totalInput > transfer.amount
              then do
                changeCid <- create TestToken with
                  owner = transfer.sender
                  instrumentAdmin = admin
                  amount = totalInput - transfer.amount
                  instrumentId = instrId.id
                  lock = None
                  metadata = transfer.meta.values
                return [toInterfaceContractId @Token.Holding.Holding changeCid]
              else return []

        -- Create transfer instruction in pending receiver acceptance state
        instrCid <- create TestTokenTransferInstruction with
          transfer
          status = Token.Transfer.TransferPendingReceiverAcceptance
          originalInstructionCid = None

        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Pending with
            transferInstructionCid = toInterfaceContractId @Token.Transfer.TransferInstruction instrCid
          senderChangeCids = changeCids
          meta = Token.Metadata.emptyMetadata

      transferFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.Transfer.TransferFactoryView with
          admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Transfer Instruction
----------------------------------------------------------------------------------------------------

-- | A transfer instruction tracking the state of a P2P transfer.
template TestTokenTransferInstruction
  with
    transfer : Token.Transfer.Transfer
      -- ^ The transfer specification.
    status : Token.Transfer.TransferInstructionStatus
      -- ^ Current status of the transfer.
    originalInstructionCid : Optional (ContractId Token.Transfer.TransferInstruction)
      -- ^ Original instruction CID for tracking lineage.
  where
    signatory transfer.sender
    observer transfer.receiver, transfer.instrumentId.admin

    interface instance Token.Transfer.TransferInstruction for TestTokenTransferInstruction where
      view = Token.Transfer.TransferInstructionView with
        transfer
        status
        originalInstructionCid
        meta = Token.Metadata.emptyMetadata

      transferInstruction_acceptImpl self arg = do
        -- Can only accept if pending receiver acceptance
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> pure ()
          _ -> abort "Transfer is not pending receiver acceptance"

        -- Validate that input holdings were provided to the factory
        -- (If empty, automatic selection would require registry-specific extension via extraArgs)
        assertMsg "Transfer must specify input holdings (automatic selection not supported in this implementation)"
          (not $ null transfer.inputHoldingCids)

        -- Holdings were already archived by TransferFactory, change already created
        -- Just create receiver holding to complete the transfer

        -- Create receiver holding (without lock - new holdings start unlocked)
        receiverCid <- create TestToken with
          owner = transfer.receiver
          instrumentAdmin = transfer.instrumentId.admin
          amount = transfer.amount
          instrumentId = transfer.instrumentId.id
          lock = None  -- New holdings from transfers start unlocked
          metadata = transfer.meta.values

        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Completed with
            receiverHoldingCids = [toInterfaceContractId @Token.Holding.Holding receiverCid]
          senderChangeCids = []  -- Change already created by factory
          meta = Token.Metadata.emptyMetadata

      transferInstruction_rejectImpl self arg = do
        -- Can only reject if pending receiver acceptance
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> pure ()
          _ -> abort "Transfer is not pending receiver acceptance"

        -- Return holdings to sender (no-op for this simple implementation)
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferInstruction_withdrawImpl self arg = do
        -- Sender can always withdraw
        -- Return holdings to sender (no-op for this simple implementation)
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferInstruction_updateImpl self arg = do
        -- Admin can update the transfer state
        -- For this simple implementation, we don't support internal workflows
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Pending with
            transferInstructionCid = toInterfaceContractId @Token.Transfer.TransferInstruction self
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Mint Request (Propose-Accept Pattern)
----------------------------------------------------------------------------------------------------

-- | A mint request following the propose-accept pattern.
-- This allows the admin to propose minting tokens to a receiver,
-- who must explicitly accept to receive the tokens.
template TestTokenMintRequest
  with
    admin : Party
      -- ^ The admin proposing the mint.
    receiver : Party
      -- ^ The party who will receive the tokens if they accept.
    amount : Decimal
      -- ^ The amount of tokens to mint.
    instrumentId : Text
      -- ^ The instrument ID for the token.
    initialLock : Optional Token.Holding.Lock
      -- ^ Optional initial lock on the minted tokens.
    metadata : TextMap.TextMap Text
      -- ^ Metadata for the minted token.
  where
    signatory admin
    observer receiver

    ensure amount > 0.0

    choice Accept : ContractId TestToken
      -- ^ Accept the mint request and create the token.
      controller receiver
      do
        create TestToken with
          owner = receiver
          instrumentAdmin = admin
          amount
          instrumentId
          lock = initialLock
          metadata

    choice Reject : ()
      -- ^ Reject the mint request.
      controller receiver
      do
        pure ()

    choice Withdraw : ()
      -- ^ Withdraw the mint request.
      controller admin
      do
        pure ()

----------------------------------------------------------------------------------------------------
-- Burn/Mint Factory
----------------------------------------------------------------------------------------------------

-- | Factory for burn and mint operations.
template TestTokenBurnMintFactory
  with
    admin : Party
      -- ^ The registry admin party.
    instrumentId : Text
      -- ^ The instrument ID for this factory.
  where
    signatory admin

    -- Propose mint using propose-accept pattern (only requires admin authorization)
    nonconsuming choice ProposeMint : ContractId TestTokenMintRequest
      with
        receiver : Party
        amount : Decimal
      controller admin
      do
        create TestTokenMintRequest with
          admin
          receiver
          amount
          instrumentId
          initialLock = None  -- Default to no lock, can be customized
          metadata = TextMap.fromList
            [ ("example.com/instrument-id", instrumentId)
            , ("example.com/symbol", "TEST")
            , ("example.com/name", "Test Token")
            , ("example.com/decimals", "10")
            ]

    -- Template choice wrapper for HTTP API compatibility (direct mint, requires receiver authorization)
    nonconsuming choice Mint : Token.BurnMint.BurnMintFactory_BurnMintResult
      with
        receiver : Party
        amount : Decimal
        extraActors : [Party]
      controller admin, receiver :: extraActors
      do
        let interfaceCid = toInterfaceContractId @Token.BurnMint.BurnMintFactory self
        exercise interfaceCid Token.BurnMint.BurnMintFactory_BurnMint with
          expectedAdmin = admin
          instrumentId = Token.Holding.InstrumentId with
            admin
            id = instrumentId
          inputHoldingCids = []
          outputs = [Token.BurnMint.BurnMintOutput with
            owner = receiver
            amount = amount
            context = Token.Metadata.ChoiceContext with values = TextMap.empty]
          extraActors = extraActors
          extraArgs = Token.Metadata.ExtraArgs with
            context = Token.Metadata.ChoiceContext with values = TextMap.empty
            meta = Token.Metadata.emptyMetadata

    interface instance Token.BurnMint.BurnMintFactory for TestTokenBurnMintFactory where
      view = Token.BurnMint.BurnMintFactoryView with
        admin
        meta = Token.Metadata.emptyMetadata

      burnMintFactory_burnMintImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        assertMsg "Instrument admin mismatch" (arg.instrumentId.admin == admin)
        assertMsg "Instrument ID mismatch" (arg.instrumentId.id == instrumentId)

        -- Archive all input holdings
        forA_ arg.inputHoldingCids (\cid -> archive cid)

        -- Create output holdings (newly minted holdings start unlocked unless specified)
        outputCids <- mapA (\output -> do
          cid <- create TestToken with
            owner = output.owner
            instrumentAdmin = admin
            amount = output.amount
            instrumentId = instrumentId
            lock = None  -- Newly minted holdings start unlocked
            metadata = TextMap.fromList
              [ ("example.com/instrument-id", instrumentId)
              , ("example.com/symbol", "TEST")
              , ("example.com/name", "Test Token")
              , ("example.com/decimals", "10")
              ]
          return (toInterfaceContractId @Token.Holding.Holding cid)
          ) arg.outputs

        return Token.BurnMint.BurnMintFactory_BurnMintResult with
          outputCids

      burnMintFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.BurnMint.BurnMintFactoryView with
          admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Lock Factory
----------------------------------------------------------------------------------------------------

-- | Factory for managing lock operations on token holdings.
-- This enables controlled locking for DVP, escrow, and other use cases.
template TestTokenLockFactory
  with
    admin : Party
      -- ^ The registry admin party.
    instrumentId : Text
      -- ^ The instrument ID this factory manages.
  where
    signatory admin

    -- | Create a lock on an existing holding.
    nonconsuming choice CreateLock : ContractId TestToken
      with
        holdingCid : ContractId TestToken
        lockHolders : [Party]
        expiresAt : Optional Time
        expiresAfter : Optional RelTime
        context : Optional Text
      controller admin
      do
        -- Fetch the holding
        holding <- fetch holdingCid

        -- Ensure holding matches this factory's instrument
        assertMsg "Instrument ID mismatch" (holding.instrumentId == instrumentId)
        assertMsg "Instrument admin mismatch" (holding.instrumentAdmin == admin)

        -- Ensure holding is not already locked
        case holding.lock of
          Some _ -> error "Holding is already locked"
          None -> pure ()

        -- Create the lock
        let newLock = Token.Holding.Lock with
              holders = lockHolders
              expiresAt = expiresAt
              expiresAfter = expiresAfter
              context = context

        -- Archive old holding and create locked version
        archive holdingCid
        create holding with lock = Some newLock

    -- | Release an expired lock.
    nonconsuming choice ReleaseExpiredLock : ContractId TestToken
      with
        holdingCid : ContractId TestToken
      controller admin
      do
        -- Fetch the holding
        holding <- fetch holdingCid

        -- Ensure holding matches this factory's instrument
        assertMsg "Instrument ID mismatch" (holding.instrumentId == instrumentId)
        assertMsg "Instrument admin mismatch" (holding.instrumentAdmin == admin)

        -- Check if lock exists and is expired
        case holding.lock of
          None -> error "No lock to release"
          Some lockInfo -> do
            now <- getTime
            let isExpired = case (lockInfo.expiresAt, lockInfo.expiresAfter) of
                  (Some absTime, _) -> now >= absTime
                  (_, _) -> False

            assertMsg "Lock has not expired" isExpired

            -- Archive old holding and create unlocked version
            archive holdingCid
            create holding with lock = None

    -- | Force unlock by admin (for emergency situations).
    nonconsuming choice ForceUnlock : ContractId TestToken
      with
        holdingCid : ContractId TestToken
        reason : Text
      controller admin
      do
        -- Fetch the holding
        holding <- fetch holdingCid

        -- Ensure holding matches this factory's instrument
        assertMsg "Instrument ID mismatch" (holding.instrumentId == instrumentId)
        assertMsg "Instrument admin mismatch" (holding.instrumentAdmin == admin)

        -- Archive old holding and create unlocked version with reason in metadata
        archive holdingCid
        create holding with
          lock = None
          metadata = TextMap.insert "force-unlock-reason" reason holding.metadata

----------------------------------------------------------------------------------------------------
-- Helper Functions
----------------------------------------------------------------------------------------------------

-- | Archive holdings and return the total amount, validating locks.
archiveAndSumHoldings : [ContractId Token.Holding.Holding] -> Update Decimal
archiveAndSumHoldings cids = do
  now <- getTime
  amounts <- mapA (\cid -> do
      holding <- fetch cid
      let holdingView = view holding

      -- Check for locks on the holding
      case holdingView.lock of
        None -> pure ()  -- No lock, can proceed
        Some lockInfo -> do
          -- Check if lock has expired (CIP-56 allows using expired locks)
          let isExpired = case (lockInfo.expiresAt, lockInfo.expiresAfter) of
                (Some absTime, _) -> now >= absTime
                (_, _) -> False  -- If no absolute expiry, consider not expired

          assertMsg ("Cannot use locked holding (lock not expired). Context: " <> show lockInfo.context)
            isExpired

      archive cid
      return holdingView.amount
    ) cids
  return (sum amounts)
