-- Copyright (c) 2025 Silvana. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Production-ready token implementation following Canton Token Standard (CIP-56).
--
-- This module implements a complete CIP-56 compliant token with:
-- - HoldingV1: Balance representation with lock support
-- - TransferFactory + TransferInstruction: P2P transfers (FOP - Free of Payment)
-- - TransferPreapproval: Instant payments without receiver signature (Amulet-inspired)
-- - AllocationFactory + AllocationInstruction + Allocation: DVP settlements (Delivery vs Payment)
-- - BurnMintFactory: Token issuance and redemption
-- - LockFactory: Holding lock management for escrow and DVP
module TestToken where

import Splice.Api.Token.MetadataV1 qualified as Token.Metadata
import Splice.Api.Token.HoldingV1 qualified as Token.Holding
import Splice.Api.Token.TransferInstructionV1 qualified as Token.Transfer
import Splice.Api.Token.BurnMintV1 qualified as Token.BurnMint
import Splice.Api.Token.AllocationV1 qualified as Token.Allocation
import Splice.Api.Token.AllocationInstructionV1 qualified as Token.AllocInstruction
import DA.TextMap qualified as TextMap
import DA.Map qualified as Map
import DA.Foldable (forA_)
import DA.Time (RelTime)
import DA.Text (isInfixOf)
import DA.Text qualified as Text
import DA.Optional (isNone)

----------------------------------------------------------------------------------------------------
-- Holding Template
----------------------------------------------------------------------------------------------------

-- | A CIP-56 compliant token holding.
template TestToken
  with
    owner : Party
      -- ^ The party that owns this token holding.
    instrumentAdmin : Party
      -- ^ The registry/admin party administering this instrument (per CIP-56).
    amount : Decimal
      -- ^ The amount of tokens in this holding.
    instrumentId : Text
      -- ^ The identifier for this token instrument.
    lock : Optional Token.Holding.Lock
      -- ^ Optional lock on this holding (for DVP, escrow, etc.).
    metadata : TextMap.TextMap Text
      -- ^ Additional metadata for this holding.
  where
    signatory owner, instrumentAdmin
    observer (optional [] (\l -> l.holders) lock)
      -- ^ Lock holders are observers to enable them to see locked holdings

    ensure amount > 0.0

    -- Implement the Holding interface for CIP-56 compliance
    interface instance Token.Holding.Holding for TestToken where
      view = Token.Holding.HoldingView with
        owner
        instrumentId = Token.Holding.InstrumentId with
          admin = instrumentAdmin
          id = instrumentId
        amount
        lock = lock
        meta = Token.Metadata.Metadata with values = metadata

    -- Lock management choices

    -- | Lock this holding with the specified lock parameters.
    choice LockHolding : ContractId TestToken
      with
        newLock : Token.Holding.Lock
      controller owner
      do
        -- Validate lock parameters
        assertMsg "Lock must have at least one holder" (not $ null newLock.holders)
        create this with lock = Some newLock

    -- | Unlock this holding if the lock has expired or if authorized.
    choice UnlockHolding : ContractId TestToken
      controller owner
      do
        case lock of
          None -> abort "No lock to unlock"
          Some currentLock -> do
            -- Validate lock has expiry information
            case (currentLock.expiresAt, currentLock.expiresAfter) of
              (None, Some _) -> abort "Relative expiry not yet supported in unlock"
              (None, None) -> abort "Lock has no expiry"
              _ -> pure ()

            -- Check if lock is expired
            now <- getTime
            let expiryTime = case currentLock.expiresAt of
                  Some absTime -> absTime
                  None -> error "Lock expiry validation failed"  -- Should not reach here

            assertMsg "Lock has not expired yet" (now >= expiryTime)
            create this with lock = None

    -- | Merge multiple holdings into a single holding to prevent UTXO fragmentation.
    -- Helps mitigate griefing attacks where malicious actors create many small holdings.
    -- Note: Requires admin authority since creating a new holding needs both owner and admin signatures.
    -- In production, this would be exposed via a registry/factory pattern (like AmuletRules).
    choice MergeHoldings : ContractId TestToken
      with
        otherHoldingCids : [ContractId TestToken]
        admin : Party  -- Admin must authorize to create the merged holding
      controller owner, admin
      do
        -- Validate this holding is unlocked
        assertMsg "Cannot merge locked holdings" (isNone lock)
        assertMsg "Admin must match instrumentAdmin" (admin == instrumentAdmin)

        -- Fetch and validate other holdings
        otherHoldings <- mapA fetch otherHoldingCids
        forA_ otherHoldings $ \other -> do
          assertMsg "All holdings must have the same owner" (other.owner == owner)
          assertMsg "All holdings must have the same instrument admin" (other.instrumentAdmin == instrumentAdmin)
          assertMsg "All holdings must have the same instrument ID" (other.instrumentId == instrumentId)
          assertMsg "Cannot merge locked holdings" (isNone other.lock)

        -- Archive all holdings including this one
        archive self
        forA_ otherHoldingCids archive

        -- Calculate total amount
        let totalAmount = amount + sum (map (\h -> h.amount) otherHoldings)

        -- Create merged holding
        now <- getTime
        create this with
          amount = totalAmount
          lock = None
          metadata = createStandardMetadata "merge-holdings" metadata now

----------------------------------------------------------------------------------------------------
-- Transfer Pre-approval (Amulet-inspired pattern for instant payments)
----------------------------------------------------------------------------------------------------

-- | Result types for transfer pre-approval operations
data TransferPreapproval_UseResult = TransferPreapproval_UseResult with
    receiverHoldingCid : ContractId TestToken
      -- ^ The holding created for the receiver
    senderChangeCid : Optional (ContractId TestToken)
      -- ^ Change holding returned to sender (if any)
  deriving (Eq, Show)

data TransferPreapproval_RenewResult = TransferPreapproval_RenewResult with
    newPreapprovalCid : ContractId TestTokenTransferPreapproval
      -- ^ The renewed pre-approval contract
  deriving (Eq, Show)

data TransferPreapproval_CancelResult = TransferPreapproval_CancelResult
  deriving (Eq, Show)

-- | A pre-approval by a receiver to accept token transfers from any sender without signature.
--
-- This enables instant payments and is inspired by Amulet's TransferPreapproval pattern.
-- Pre-approvals can be self-managed (provider = receiver) or managed by an app provider.
--
-- Unlike Amulet, TestToken pre-approvals:
-- - Do not require fee burning (no economic cost for indexing)
-- - Use admin party instead of DSO party
-- - Are simpler without reward coupon integration
template TestTokenTransferPreapproval
  with
    receiver : Party
      -- ^ The party that will receive transfers via this pre-approval.
    provider : Party
      -- ^ The party managing this pre-approval (can be same as receiver for self-managed).
    admin : Party
      -- ^ The registry admin party.
    instrumentId : Text
      -- ^ The instrument ID for this token.
    validFrom : Time
      -- ^ When this pre-approval becomes valid.
    lastRenewedAt : Time
      -- ^ When this pre-approval was last renewed (equals validFrom on creation).
    expiresAt : Time
      -- ^ When this pre-approval expires.
    metadata : TextMap.TextMap Text
      -- ^ Additional metadata for tracking.
  where
    signatory receiver, provider, admin

    ensure expiresAt > validFrom && lastRenewedAt >= validFrom

    -- | Use the pre-approval to transfer tokens instantly.
    -- Any party can use this to send tokens to the receiver.
    choice UsePreapproval : TransferPreapproval_UseResult
      with
        sender : Party
          -- ^ The party sending tokens.
        senderHoldingCid : ContractId TestToken
          -- ^ The sender's holding to use for payment.
        amount : Decimal
          -- ^ The amount to transfer.
        transferContext : TextMap.TextMap Text
          -- ^ Additional context for this transfer.
      controller sender
      do
        -- Validate timing
        now <- getTime
        assertMsg "Pre-approval not yet valid" (now >= validFrom)
        assertMsg "Pre-approval has expired" (now < expiresAt)

        -- Fetch and validate sender's holding
        senderHolding <- fetch senderHoldingCid
        assertMsg "Sender must own the holding" (senderHolding.owner == sender)
        assertMsg "Instrument ID mismatch" (senderHolding.instrumentId == instrumentId)
        assertMsg "Admin mismatch" (senderHolding.instrumentAdmin == admin)
        assertMsg "Holding must not be locked" (isNone senderHolding.lock)
        assertMsg "Insufficient balance" (senderHolding.amount >= amount)

        -- Archive sender's holding
        archive senderHoldingCid

        -- Create receiver's holding
        receiverCid <- create TestToken with
          owner = receiver
          instrumentAdmin = admin
          amount = amount
          instrumentId = instrumentId
          lock = None
          metadata = TextMap.union transferContext $
            TextMap.insert "splice.lfdecentralizedtrust.org/transfer-type" "preapproval-instant" $
            TextMap.insert "splice.lfdecentralizedtrust.org/timestamp" (show now) metadata

        -- Create change holding for sender if needed
        changeCidOpt <- if senderHolding.amount > amount
          then do
            changeCid <- create TestToken with
              owner = sender
              instrumentAdmin = admin
              amount = senderHolding.amount - amount
              instrumentId = instrumentId
              lock = None
              metadata = createStandardMetadata "preapproval-change" transferContext now
            return (Some changeCid)
          else return None

        return TransferPreapproval_UseResult with
          receiverHoldingCid = receiverCid
          senderChangeCid = changeCidOpt

    -- | Renew the pre-approval to extend its expiry.
    choice RenewPreapproval : TransferPreapproval_RenewResult
      with
        newExpiresAt : Time
          -- ^ The new expiry time (must be after current expiry).
      controller provider
      do
        now <- getTime
        assertMsg "Pre-approval has already expired" (now < expiresAt)
        assertMsg "New expiry must be after current expiry" (newExpiresAt > expiresAt)

        -- Create renewed pre-approval
        newCid <- create this with
          lastRenewedAt = now
          expiresAt = newExpiresAt
          metadata = TextMap.insert "splice.lfdecentralizedtrust.org/renewed-at" (show now) metadata

        return TransferPreapproval_RenewResult with
          newPreapprovalCid = newCid

    -- | Cancel the pre-approval before expiry.
    -- Can be called by either receiver or provider.
    choice CancelPreapproval : TransferPreapproval_CancelResult
      with
        canceller : Party
          -- ^ The party cancelling (must be receiver or provider).
      controller canceller
      do
        assertMsg "Only receiver or provider can cancel"
          (canceller == receiver || canceller == provider)
        return TransferPreapproval_CancelResult

----------------------------------------------------------------------------------------------------
-- Transfer Factory
----------------------------------------------------------------------------------------------------

-- | Factory for creating transfer instructions between parties.
--
-- Note: For instant payments without receiver signature, use TestTokenTransferPreapproval instead.
-- This factory creates standard CIP-56 transfer instructions that require receiver acceptance.
template TestTokenTransferFactory
  with
    admin : Party
      -- ^ The registry admin party.
  where
    signatory admin

    interface instance Token.Transfer.TransferFactory for TestTokenTransferFactory where
      view = Token.Transfer.TransferFactoryView with
        admin
        meta = Token.Metadata.emptyMetadata

      transferFactory_transferImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)

        let transfer = arg.transfer
        let instrId = transfer.instrumentId

        -- Validate instrument admin matches factory admin
        assertMsg "Instrument admin must match factory admin" (instrId.admin == admin)

        -- Validate executeBefore is in the future
        now <- getTime
        assertMsg "executeBefore must be in the future" (transfer.executeBefore > now)
        assertMsg "requestedAt must be in the past" (transfer.requestedAt <= now)

        -- Handle input holdings if provided (enables contention-based duplicate prevention)
        changeCids <- if null transfer.inputHoldingCids
          then
            -- Empty list: automatic selection mode (holdings will be selected at Accept time)
            return []
          else do
            -- Provided list: explicit UTXO selection mode
            -- Fetch and validate all input holdings as interface contracts
            holdingViews <- mapA (\cid -> do
              holding <- fetch (coerceContractId @Token.Holding.Holding cid)
              return (view (holding : Token.Holding.Holding))
              ) transfer.inputHoldingCids

            -- Validate each holding
            forA_ holdingViews $ \holdingView -> do
              assertMsg "Input holding owner must be sender"
                (holdingView.owner == transfer.sender)
              assertMsg "Input holding instrument mismatch"
                (holdingView.instrumentId == transfer.instrumentId)

              -- Validate lock status
              case holdingView.lock of
                None -> pure ()
                Some lockInfo -> do
                  let expired = isLockExpired now lockInfo
                  assertMsg ("Cannot use locked holding in transfer. Context: " <>
                             optional "none" (\c -> c) lockInfo.context <>
                             ". Expires at: " <> show lockInfo.expiresAt <>
                             ". Current time: " <> show now)
                    expired

            -- Calculate total input
            let totalInput = sum $ map (\v -> v.amount) holdingViews

            -- Validate sufficient funds
            assertMsg "Insufficient input holdings for transfer amount"
              (totalInput >= transfer.amount)

            -- Archive input holdings (creates deliberate contention)
            forA_ transfer.inputHoldingCids archive

            -- Create change holding if needed
            if totalInput > transfer.amount
              then do
                changeCid <- create TestToken with
                  owner = transfer.sender
                  instrumentAdmin = admin
                  amount = totalInput - transfer.amount
                  instrumentId = instrId.id
                  lock = None
                  metadata = createStandardMetadata "transfer-change" transfer.meta.values now
                return [toInterfaceContractId @Token.Holding.Holding changeCid]
              else return []

        -- Create transfer instruction in pending receiver acceptance state
        instrCid <- create TestTokenTransferInstruction with
          transfer
          status = Token.Transfer.TransferPendingReceiverAcceptance
          originalInstructionCid = None

        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Pending with
            transferInstructionCid = toInterfaceContractId @Token.Transfer.TransferInstruction instrCid
          senderChangeCids = changeCids
          meta = Token.Metadata.emptyMetadata

      transferFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.Transfer.TransferFactoryView with
          admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Transfer Instruction
----------------------------------------------------------------------------------------------------

-- | A transfer instruction tracking the state of a P2P transfer.
template TestTokenTransferInstruction
  with
    transfer : Token.Transfer.Transfer
      -- ^ The transfer specification.
    status : Token.Transfer.TransferInstructionStatus
      -- ^ Current status of the transfer.
    originalInstructionCid : Optional (ContractId Token.Transfer.TransferInstruction)
      -- ^ Original instruction CID for tracking lineage.
  where
    signatory transfer.sender
    observer transfer.receiver, transfer.instrumentId.admin

    interface instance Token.Transfer.TransferInstruction for TestTokenTransferInstruction where
      view = Token.Transfer.TransferInstructionView with
        transfer
        status
        originalInstructionCid
        meta = Token.Metadata.emptyMetadata

      transferInstruction_acceptImpl self arg = do
        -- Can only accept if pending receiver acceptance
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> pure ()
          _ -> abort "Transfer is not pending receiver acceptance"

        -- Validate that input holdings were provided to the factory
        -- (If empty, automatic selection would require registry-specific extension via extraArgs)
        assertMsg "Transfer must specify input holdings (automatic selection not supported in this implementation)"
          (not $ null transfer.inputHoldingCids)

        -- Holdings were already archived by TransferFactory, change already created
        -- Just create receiver holding to complete the transfer
        now <- getTime

        -- Create receiver holding (without lock - new holdings start unlocked)
        receiverCid <- create TestToken with
          owner = transfer.receiver
          instrumentAdmin = transfer.instrumentId.admin
          amount = transfer.amount
          instrumentId = transfer.instrumentId.id
          lock = None  -- New holdings from transfers start unlocked
          metadata = createStandardMetadata "transfer-accept" transfer.meta.values now

        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Completed with
            receiverHoldingCids = [toInterfaceContractId @Token.Holding.Holding receiverCid]
          senderChangeCids = []  -- Change already created by factory
          meta = Token.Metadata.emptyMetadata

      transferInstruction_rejectImpl self arg = do
        -- Can only reject if pending receiver acceptance
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> pure ()
          _ -> abort "Transfer is not pending receiver acceptance"

        -- Return holdings to sender (no-op for this simple implementation)
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferInstruction_withdrawImpl self arg = do
        -- Sender can always withdraw
        -- Return holdings to sender (no-op for this simple implementation)
        return Token.Transfer.TransferInstructionResult with
          output = Token.Transfer.TransferInstructionResult_Failed
          senderChangeCids = []
          meta = Token.Metadata.emptyMetadata

      transferInstruction_updateImpl self arg = do
        -- Admin can update the transfer state for internal workflows
        -- Supports transitions between pending states
        case status of
          Token.Transfer.TransferPendingReceiverAcceptance -> do
            -- Transition to internal workflow state
            -- This is used when registry needs internal approvals (e.g., compliance, AML)
            newInstr <- create this with
              status = Token.Transfer.TransferPendingInternalWorkflow with
                pendingActions = Map.fromList
                  [(actor, "Internal compliance review required") | actor <- arg.extraActors]
              originalInstructionCid = case originalInstructionCid of
                Some cid -> Some cid  -- Preserve original
                None -> Some (toInterfaceContractId @Token.Transfer.TransferInstruction self)

            return Token.Transfer.TransferInstructionResult with
              output = Token.Transfer.TransferInstructionResult_Pending with
                transferInstructionCid = toInterfaceContractId newInstr
              senderChangeCids = []
              meta = Token.Metadata.emptyMetadata

          Token.Transfer.TransferPendingInternalWorkflow pendingActions -> do
            -- Complete internal workflow and return to receiver acceptance
            -- or advance to another internal state
            let updatedActions = if null arg.extraActors
                  then Map.empty  -- Clear all pending actions
                  else Map.fromList
                    [(actor, "Additional review required") | actor <- arg.extraActors]

            let newStatus = if Map.null updatedActions
                  then Token.Transfer.TransferPendingReceiverAcceptance  -- Back to receiver acceptance
                  else Token.Transfer.TransferPendingInternalWorkflow with
                    pendingActions = updatedActions

            newInstr <- create this with
              status = newStatus
              originalInstructionCid = originalInstructionCid  -- Preserve lineage

            return Token.Transfer.TransferInstructionResult with
              output = Token.Transfer.TransferInstructionResult_Pending with
                transferInstructionCid = toInterfaceContractId newInstr
              senderChangeCids = []
              meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Transfer Pre-approval Factory
----------------------------------------------------------------------------------------------------

-- | Factory for creating transfer pre-approvals.
-- This enables receivers to pre-approve incoming transfers for instant payments.
template TestTokenTransferPreapprovalFactory
  with
    admin : Party
      -- ^ The registry admin party.
  where
    signatory admin

    -- | Create a new transfer pre-approval.
    -- Requires authorization from both receiver and provider.
    nonconsuming choice CreateTransferPreapproval : ContractId TestTokenTransferPreapproval
      with
        receiver : Party
          -- ^ The party that will receive transfers.
        provider : Party
          -- ^ The party managing the pre-approval (can be same as receiver).
        instrumentId : Text
          -- ^ The instrument ID for this token.
        expiresAt : Time
          -- ^ When this pre-approval expires.
        preapprovalMetadata : TextMap.TextMap Text
          -- ^ Additional metadata for the pre-approval.
        expectedAdmin : Optional Party
          -- ^ Expected admin party (security: prevents delegation attacks).
      controller receiver, provider
      do
        checkExpectedAdmin admin expectedAdmin
        now <- getTime
        assertMsg "Expiry must be in the future" (expiresAt > now)

        create TestTokenTransferPreapproval with
          receiver
          provider
          admin
          instrumentId
          validFrom = now
          lastRenewedAt = now
          expiresAt
          metadata = TextMap.union preapprovalMetadata $
            TextMap.fromList
              [ ("splice.lfdecentralizedtrust.org/created-at", show now)
              , ("splice.lfdecentralizedtrust.org/instrument-id", instrumentId)
              ]

----------------------------------------------------------------------------------------------------
-- Mint Request (Propose-Accept Pattern)
----------------------------------------------------------------------------------------------------

-- | A mint request following the propose-accept pattern.
-- This allows the admin to propose minting tokens to a receiver,
-- who must explicitly accept to receive the tokens.
template TestTokenMintRequest
  with
    admin : Party
      -- ^ The admin proposing the mint.
    receiver : Party
      -- ^ The party who will receive the tokens if they accept.
    amount : Decimal
      -- ^ The amount of tokens to mint.
    instrumentId : Text
      -- ^ The instrument ID for the token.
    initialLock : Optional Token.Holding.Lock
      -- ^ Optional initial lock on the minted tokens.
    metadata : TextMap.TextMap Text
      -- ^ Metadata for the minted token.
  where
    signatory admin
    observer receiver

    ensure amount > 0.0

    choice Accept : ContractId TestToken
      -- ^ Accept the mint request and create the token.
      controller receiver
      do
        create TestToken with
          owner = receiver
          instrumentAdmin = admin
          amount
          instrumentId
          lock = initialLock
          metadata

    choice Reject : ()
      -- ^ Reject the mint request.
      controller receiver
      do
        pure ()

    choice Withdraw : ()
      -- ^ Withdraw the mint request.
      controller admin
      do
        pure ()

----------------------------------------------------------------------------------------------------
-- Burn/Mint Factory
----------------------------------------------------------------------------------------------------

-- | Factory for burn and mint operations.
template TestTokenBurnMintFactory
  with
    admin : Party
      -- ^ The registry admin party.
    instrumentId : Text
      -- ^ The instrument ID for this factory.
  where
    signatory admin

    -- Propose mint using propose-accept pattern (only requires admin authorization)
    nonconsuming choice ProposeMint : ContractId TestTokenMintRequest
      with
        receiver : Party
        amount : Decimal
        expectedAdmin : Optional Party
          -- ^ Expected admin party (security: prevents delegation attacks).
      controller admin
      do
        checkExpectedAdmin admin expectedAdmin
        create TestTokenMintRequest with
          admin
          receiver
          amount
          instrumentId
          initialLock = None  -- Default to no lock, can be customized
          metadata = TextMap.fromList
            [ ("example.com/instrument-id", instrumentId)
            , ("example.com/symbol", "TEST")
            , ("example.com/name", "Test Token")
            , ("example.com/decimals", "10")
            ]

    -- Template choice wrapper for HTTP API compatibility (direct mint, requires receiver authorization)
    nonconsuming choice Mint : Token.BurnMint.BurnMintFactory_BurnMintResult
      with
        receiver : Party
        amount : Decimal
        extraActors : [Party]
      controller admin, receiver :: extraActors
      do
        let interfaceCid = toInterfaceContractId @Token.BurnMint.BurnMintFactory self
        exercise interfaceCid Token.BurnMint.BurnMintFactory_BurnMint with
          expectedAdmin = admin
          instrumentId = Token.Holding.InstrumentId with
            admin
            id = instrumentId
          inputHoldingCids = []
          outputs = [Token.BurnMint.BurnMintOutput with
            owner = receiver
            amount = amount
            context = Token.Metadata.ChoiceContext with values = TextMap.empty]
          extraActors = extraActors
          extraArgs = Token.Metadata.ExtraArgs with
            context = Token.Metadata.ChoiceContext with values = TextMap.empty
            meta = Token.Metadata.emptyMetadata

    interface instance Token.BurnMint.BurnMintFactory for TestTokenBurnMintFactory where
      view = Token.BurnMint.BurnMintFactoryView with
        admin
        meta = Token.Metadata.emptyMetadata

      burnMintFactory_burnMintImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        assertMsg "Instrument admin mismatch" (arg.instrumentId.admin == admin)
        assertMsg "Instrument ID mismatch" (arg.instrumentId.id == instrumentId)

        -- Archive all input holdings
        forA_ arg.inputHoldingCids (\cid -> archive cid)

        -- Create output holdings (newly minted holdings start unlocked unless specified)
        outputCids <- mapA (\output -> do
          cid <- create TestToken with
            owner = output.owner
            instrumentAdmin = admin
            amount = output.amount
            instrumentId = instrumentId
            lock = None  -- Newly minted holdings start unlocked
            metadata = TextMap.fromList
              [ ("example.com/instrument-id", instrumentId)
              , ("example.com/symbol", "TEST")
              , ("example.com/name", "Test Token")
              , ("example.com/decimals", "10")
              ]
          return (toInterfaceContractId @Token.Holding.Holding cid)
          ) arg.outputs

        return Token.BurnMint.BurnMintFactory_BurnMintResult with
          outputCids

      burnMintFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.BurnMint.BurnMintFactoryView with
          admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Lock Factory
----------------------------------------------------------------------------------------------------

-- | Factory for managing lock operations on token holdings.
-- This enables controlled locking for DVP, escrow, and other use cases.
template TestTokenLockFactory
  with
    admin : Party
      -- ^ The registry admin party.
    instrumentId : Text
      -- ^ The instrument ID this factory manages.
  where
    signatory admin

    -- | Create a lock on an existing holding.
    nonconsuming choice CreateLock : ContractId TestToken
      with
        holdingCid : ContractId TestToken
        lockHolders : [Party]
        expiresAt : Optional Time
        expiresAfter : Optional RelTime
        context : Optional Text
        expectedAdmin : Optional Party
          -- ^ Expected admin party (security: prevents delegation attacks).
      controller admin
      do
        checkExpectedAdmin admin expectedAdmin
        -- Fetch the holding
        holding <- fetch holdingCid

        -- Ensure holding matches this factory's instrument
        assertMsg "Instrument ID mismatch" (holding.instrumentId == instrumentId)
        assertMsg "Instrument admin mismatch" (holding.instrumentAdmin == admin)

        -- Ensure holding is not already locked
        case holding.lock of
          Some _ -> error "Holding is already locked"
          None -> pure ()

        -- Create the lock
        let newLock = Token.Holding.Lock with
              holders = lockHolders
              expiresAt = expiresAt
              expiresAfter = expiresAfter
              context = context

        -- Archive old holding and create locked version
        archive holdingCid
        create holding with lock = Some newLock

    -- | Release an expired lock.
    nonconsuming choice ReleaseExpiredLock : ContractId TestToken
      with
        holdingCid : ContractId TestToken
        expectedAdmin : Optional Party
          -- ^ Expected admin party (security: prevents delegation attacks).
      controller admin
      do
        checkExpectedAdmin admin expectedAdmin
        -- Fetch the holding
        holding <- fetch holdingCid

        -- Ensure holding matches this factory's instrument
        assertMsg "Instrument ID mismatch" (holding.instrumentId == instrumentId)
        assertMsg "Instrument admin mismatch" (holding.instrumentAdmin == admin)

        -- Check if lock exists and is expired
        case holding.lock of
          None -> error "No lock to release"
          Some lockInfo -> do
            now <- getTime
            let isExpired = case (lockInfo.expiresAt, lockInfo.expiresAfter) of
                  (Some absTime, _) -> now >= absTime
                  (_, _) -> False

            assertMsg "Lock has not expired" isExpired

            -- Archive old holding and create unlocked version
            archive holdingCid
            create holding with lock = None

    -- | Force unlock by admin (for emergency situations).
    nonconsuming choice ForceUnlock : ContractId TestToken
      with
        holdingCid : ContractId TestToken
        reason : Text
        expectedAdmin : Optional Party
          -- ^ Expected admin party (security: prevents delegation attacks).
      controller admin
      do
        checkExpectedAdmin admin expectedAdmin
        -- Fetch the holding
        holding <- fetch holdingCid

        -- Ensure holding matches this factory's instrument
        assertMsg "Instrument ID mismatch" (holding.instrumentId == instrumentId)
        assertMsg "Instrument admin mismatch" (holding.instrumentAdmin == admin)

        -- Archive old holding and create unlocked version with reason in metadata
        archive holdingCid
        create holding with
          lock = None
          metadata = TextMap.insert "force-unlock-reason" reason holding.metadata

----------------------------------------------------------------------------------------------------
-- Allocation (DVP Settlement Support)
----------------------------------------------------------------------------------------------------

-- | Allocation of holdings for atomic DVP (Delivery versus Payment) settlements.
-- Represents a reserved holding for a specific leg of a multi-party settlement.
template TestTokenAllocation
  with
    admin : Party
      -- ^ The registry admin party.
    allocation : Token.Allocation.AllocationSpecification
      -- ^ The settlement specification for this allocation.
    holdingCids : [ContractId Token.Holding.Holding]
      -- ^ The holdings backing this allocation.
  where
    signatory admin, allocation.transferLeg.sender
    observer allocation.settlement.executor, allocation.transferLeg.receiver

    interface instance Token.Allocation.Allocation for TestTokenAllocation where
      view = Token.Allocation.AllocationView with
        allocation = allocation
        holdingCids = holdingCids
        meta = Token.Metadata.emptyMetadata

      allocation_executeTransferImpl self arg = do
        let TestTokenAllocation{..} = this
        -- Validate settlement deadline
        now <- getTime
        assertMsg "Settlement deadline has passed"
          (now < allocation.settlement.settleBefore)

        -- Archive allocated holdings
        forA_ holdingCids archive

        -- Create receiver holding with settlement metadata
        receiverCid <- create TestToken with
          owner = allocation.transferLeg.receiver
          instrumentAdmin = allocation.transferLeg.instrumentId.admin
          amount = allocation.transferLeg.amount
          instrumentId = allocation.transferLeg.instrumentId.id
          lock = None
          metadata = TextMap.fromList
            [ ("splice.lfdecentralizedtrust.org/settlement-id", allocation.settlement.settlementRef.id)
            , ("splice.lfdecentralizedtrust.org/settlement-executor", show allocation.settlement.executor)
            ]

        return Token.Allocation.Allocation_ExecuteTransferResult with
          senderHoldingCids = []  -- No change - exact allocation
          receiverHoldingCids = [toInterfaceContractId @Token.Holding.Holding receiverCid]
          meta = Token.Metadata.emptyMetadata

      allocation_cancelImpl self arg = do
        let TestTokenAllocation{..} = this
        -- Return allocated holdings to sender
        -- Fetch holdings to get their amounts
        holdingViews <- mapA (\cid -> do
          holding <- fetch (coerceContractId @Token.Holding.Holding cid)
          return (view (holding : Token.Holding.Holding))
          ) holdingCids

        -- Archive old holdings
        forA_ holdingCids archive

        -- Recreate holdings for sender
        senderCids <- mapA (\holdingView -> do
          cid <- create TestToken with
            owner = allocation.transferLeg.sender
            instrumentAdmin = allocation.transferLeg.instrumentId.admin
            amount = holdingView.amount
            instrumentId = allocation.transferLeg.instrumentId.id
            lock = None
            metadata = holdingView.meta.values
          return (toInterfaceContractId @Token.Holding.Holding cid)
          ) holdingViews

        return Token.Allocation.Allocation_CancelResult with
          senderHoldingCids = senderCids
          meta = Token.Metadata.emptyMetadata

      allocation_withdrawImpl self arg = do
        let TestTokenAllocation{..} = this
        -- Sender withdraws allocation - same logic as cancel
        -- Fetch holdings to get their amounts
        holdingViews <- mapA (\cid -> do
          holding <- fetch (coerceContractId @Token.Holding.Holding cid)
          return (view (holding : Token.Holding.Holding))
          ) holdingCids

        -- Archive old holdings
        forA_ holdingCids archive

        -- Recreate holdings for sender
        senderCids <- mapA (\holdingView -> do
          cid <- create TestToken with
            owner = allocation.transferLeg.sender
            instrumentAdmin = allocation.transferLeg.instrumentId.admin
            amount = holdingView.amount
            instrumentId = allocation.transferLeg.instrumentId.id
            lock = None
            metadata = holdingView.meta.values
          return (toInterfaceContractId @Token.Holding.Holding cid)
          ) holdingViews

        return Token.Allocation.Allocation_WithdrawResult with
          senderHoldingCids = senderCids
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Allocation Instruction (DVP Request Lifecycle)
----------------------------------------------------------------------------------------------------

-- | Instruction for creating an allocation, tracking the request lifecycle.
template TestTokenAllocationInstruction
  with
    admin : Party
      -- ^ The registry admin party.
    allocation : Token.Allocation.AllocationSpecification
      -- ^ The allocation specification.
    inputHoldingCids : [ContractId Token.Holding.Holding]
      -- ^ Holdings to fund the allocation.
    requestedAt : Time
      -- ^ When the allocation was requested.
    pendingActions : Map.Map Party Text
      -- ^ Pending actions for internal workflows.
    originalInstructionCid : Optional (ContractId Token.AllocInstruction.AllocationInstruction)
      -- ^ Original instruction for lineage tracking.
  where
    signatory admin, allocation.transferLeg.sender
    observer allocation.settlement.executor, allocation.transferLeg.receiver

    interface instance Token.AllocInstruction.AllocationInstruction for TestTokenAllocationInstruction where
      view = Token.AllocInstruction.AllocationInstructionView with
        originalInstructionCid = originalInstructionCid
        allocation = allocation
        pendingActions = pendingActions
        requestedAt = requestedAt
        inputHoldingCids = inputHoldingCids
        meta = Token.Metadata.emptyMetadata

      allocationInstruction_withdrawImpl self arg = do
        let TestTokenAllocationInstruction{..} = this
        -- Sender withdraws instruction - return holdings
        holdingViews <- mapA (\cid -> do
          holding <- fetch (coerceContractId @Token.Holding.Holding cid)
          return (view (holding : Token.Holding.Holding))
          ) inputHoldingCids

        -- Archive old holdings
        forA_ inputHoldingCids archive

        -- Recreate holdings for sender
        senderCids <- mapA (\holdingView -> do
          cid <- create TestToken with
            owner = allocation.transferLeg.sender
            instrumentAdmin = allocation.transferLeg.instrumentId.admin
            amount = holdingView.amount
            instrumentId = allocation.transferLeg.instrumentId.id
            lock = None
            metadata = holdingView.meta.values
          return (toInterfaceContractId @Token.Holding.Holding cid)
          ) holdingViews

        return Token.AllocInstruction.AllocationInstructionResult with
          output = Token.AllocInstruction.AllocationInstructionResult_Failed
          senderChangeCids = senderCids
          meta = Token.Metadata.emptyMetadata

      allocationInstruction_updateImpl self arg = do
        let TestTokenAllocationInstruction{..} = this
        -- Admin updates instruction state for internal workflows
        if null arg.extraActors && Map.null pendingActions
          then do
            -- Complete workflow - create allocation
            allocCid <- create TestTokenAllocation with
              admin = admin
              allocation = allocation
              holdingCids = inputHoldingCids

            return Token.AllocInstruction.AllocationInstructionResult with
              output = Token.AllocInstruction.AllocationInstructionResult_Completed with
                allocationCid = toInterfaceContractId @Token.Allocation.Allocation allocCid
              senderChangeCids = []
              meta = Token.Metadata.emptyMetadata
          else do
            -- Update pending actions
            let newPendingActions = if null arg.extraActors
                  then Map.empty
                  else Map.fromList
                    [(actor, "Allocation approval required") | actor <- arg.extraActors]

            newInstr <- create this with
              pendingActions = newPendingActions
              originalInstructionCid = case originalInstructionCid of
                Some cid -> Some cid
                None -> Some (toInterfaceContractId @Token.AllocInstruction.AllocationInstruction self)

            return Token.AllocInstruction.AllocationInstructionResult with
              output = Token.AllocInstruction.AllocationInstructionResult_Pending with
                allocationInstructionCid = toInterfaceContractId newInstr
              senderChangeCids = []
              meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Allocation Factory (DVP Entry Point)
----------------------------------------------------------------------------------------------------

-- | Factory for creating allocations for DVP settlements.
template TestTokenAllocationFactory
  with
    admin : Party
      -- ^ The registry admin party.
  where
    signatory admin

    interface instance Token.AllocInstruction.AllocationFactory for TestTokenAllocationFactory where
      view = Token.AllocInstruction.AllocationFactoryView with
        admin = admin
        meta = Token.Metadata.emptyMetadata

      allocationFactory_allocateImpl self arg = do
        -- Validate expectedAdmin matches
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        assertMsg "Instrument admin mismatch"
          (arg.allocation.transferLeg.instrumentId.admin == admin)

        -- Validate settlement deadlines
        assertMsg "allocateBefore must be before settleBefore"
          (arg.allocation.settlement.allocateBefore < arg.allocation.settlement.settleBefore)

        -- Validate requestedAt is in the past
        now <- getTime
        assertMsg "requestedAt must be in the past" (arg.requestedAt <= now)

        if null arg.inputHoldingCids
          then do
            -- No holdings provided - create allocation instruction for later funding
            instrCid <- create TestTokenAllocationInstruction with
              admin = admin
              allocation = arg.allocation
              inputHoldingCids = arg.inputHoldingCids
              requestedAt = arg.requestedAt
              pendingActions = Map.fromList
                [(arg.allocation.transferLeg.sender, "Provide holdings for allocation")]
              originalInstructionCid = None

            return Token.AllocInstruction.AllocationInstructionResult with
              output = Token.AllocInstruction.AllocationInstructionResult_Pending with
                allocationInstructionCid = toInterfaceContractId instrCid
              senderChangeCids = []
              meta = Token.Metadata.emptyMetadata
          else do
            -- Holdings provided - validate and create allocation directly
            -- Fetch and validate holdings
            holdingViews <- mapA (\cid -> do
              holding <- fetch (coerceContractId @Token.Holding.Holding cid)
              return (view (holding : Token.Holding.Holding))
              ) arg.inputHoldingCids

            -- Validate holdings
            forA_ holdingViews $ \holdingView -> do
              assertMsg "Input holding owner must be sender"
                (holdingView.owner == arg.allocation.transferLeg.sender)
              assertMsg "Input holding instrument mismatch"
                (holdingView.instrumentId == arg.allocation.transferLeg.instrumentId)

              -- Validate lock status
              case holdingView.lock of
                None -> pure ()
                Some lockInfo -> do
                  let expired = isLockExpired now lockInfo
                  assertMsg ("Cannot allocate locked holding. Context: " <>
                             optional "none" (\c -> c) lockInfo.context <>
                             ". Expires at: " <> show lockInfo.expiresAt <>
                             ". Current time: " <> show now)
                    expired

            -- Calculate total input
            let totalInput = sum $ map (\v -> v.amount) holdingViews

            -- Validate sufficient funds
            assertMsg "Insufficient input holdings for allocation amount"
              (totalInput >= arg.allocation.transferLeg.amount)

            -- Archive input holdings
            forA_ arg.inputHoldingCids archive

            -- Create change if needed
            changeCids <- if totalInput > arg.allocation.transferLeg.amount
              then do
                changeCid <- create TestToken with
                  owner = arg.allocation.transferLeg.sender
                  instrumentAdmin = admin
                  amount = totalInput - arg.allocation.transferLeg.amount
                  instrumentId = arg.allocation.transferLeg.instrumentId.id
                  lock = None
                  metadata = TextMap.fromList
                    [("splice.lfdecentralizedtrust.org/allocation-change", "true")]
                return [toInterfaceContractId @Token.Holding.Holding changeCid]
              else return []

            -- Create allocation directly
            allocCid <- create TestTokenAllocation with
              admin = admin
              allocation = arg.allocation
              holdingCids = arg.inputHoldingCids

            return Token.AllocInstruction.AllocationInstructionResult with
              output = Token.AllocInstruction.AllocationInstructionResult_Completed with
                allocationCid = toInterfaceContractId @Token.Allocation.Allocation allocCid
              senderChangeCids = changeCids
              meta = Token.Metadata.emptyMetadata

      allocationFactory_publicFetchImpl self arg = do
        assertMsg "Expected admin mismatch" (arg.expectedAdmin == admin)
        return Token.AllocInstruction.AllocationFactoryView with
          admin = admin
          meta = Token.Metadata.emptyMetadata

----------------------------------------------------------------------------------------------------
-- Helper Functions
----------------------------------------------------------------------------------------------------

-- | Validate that the expected admin matches the actual admin.
-- This prevents malicious delegation attacks where a fake factory
-- is substituted for the real one.
--
-- Inspired by Amulet's checkExpectedDso pattern. Users must explicitly specify
-- which admin party they expect to prevent accidental use of malicious factories.
checkExpectedAdmin : Party -> Optional Party -> Update ()
checkExpectedAdmin actualAdmin optExpectedAdmin =
  case optExpectedAdmin of
    None -> abort "Expected admin not set by caller. Set expectedAdmin = Some <admin> as a security measure to prevent delegation attacks."
    Some expectedAdmin ->
      assertMsg ("Expected admin " <> show expectedAdmin <> " does not match actual admin " <> show actualAdmin)
        (actualAdmin == expectedAdmin)

-- | Validate metadata to prevent bloat and ensure proper format.
-- Checks metadata size limits and key format.
validateMetadata : TextMap.TextMap Text -> Bool
validateMetadata meta =
  TextMap.size meta <= 20 &&
  all (\(k, v) -> ("." `isInfixOf` k) || Text.length k < 50) (TextMap.toList meta) &&
  all (\(_, v) -> Text.length v <= 500) (TextMap.toList meta)

-- | Create standard metadata for a newly created holding.
-- Validates metadata before merging to ensure security.
createStandardMetadata : Text -> TextMap.TextMap Text -> Time -> TextMap.TextMap Text
createStandardMetadata source existingMeta now =
  let
    standardFields = TextMap.fromList
      [ ("splice.lfdecentralizedtrust.org/created-from", source)
      , ("splice.lfdecentralizedtrust.org/created-at", show now)
      ]
    merged = TextMap.union existingMeta standardFields
  in
    -- Validate before returning
    if validateMetadata merged
      then merged
      else standardFields  -- Fall back to just standard fields if validation fails

-- | Check if a lock has expired based on current time.
isLockExpired : Time -> Token.Holding.Lock -> Bool
isLockExpired now lock = case (lock.expiresAt, lock.expiresAfter) of
  (Some absTime, _) -> now >= absTime  -- Absolute time takes precedence
  (None, Some _) -> False  -- Relative expiry not fully supported without creation timestamp
  (None, None) -> False  -- No expiry means never expires

-- | Archive holdings and return the total amount, validating locks.
archiveAndSumHoldings : [ContractId Token.Holding.Holding] -> Update Decimal
archiveAndSumHoldings cids = do
  now <- getTime
  amounts <- mapA (\cid -> do
      holding <- fetch cid
      let holdingView = view holding

      -- Check for locks on the holding
      case holdingView.lock of
        None -> pure ()  -- No lock, can proceed
        Some lockInfo -> do
          -- Check if lock has expired (CIP-56 allows using expired locks)
          let expired = isLockExpired now lockInfo

          assertMsg ("Cannot use locked holding (lock not expired). Context: " <>
                     optional "none" (\c -> c) lockInfo.context <>
                     ". Expires at: " <> show lockInfo.expiresAt <>
                     ". Current time: " <> show now)
            expired

      archive cid
      return holdingView.amount
    ) cids
  return (sum amounts)
