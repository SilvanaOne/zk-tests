module AdvancedPayment where

import Splice.Amulet (Amulet, LockedAmulet, LockedAmulet_Unlock(..))
import Splice.AmuletRules (AppTransferContext(..), Transfer(..), TransferInput(..), TransferOutput(..), CreatedAmulet(..), exerciseAppTransfer)
import Splice.Api.FeaturedAppRightV1 (AppRewardBeneficiary(..))
import Splice.Expiry (TimeLock(..))

-- | Build lock context string, including reference if available
buildLockContext : Optional Text -> Text
buildLockContext optRef = case optRef of
  Some ref -> "AdvancedPayment [" <> ref <> "]"
  None -> "AdvancedPayment lock"

-- Result types

data AdvancedPayment_Withdraw_Result = AdvancedPayment_Withdraw_Result
  with
    advancedPaymentCid : Optional (ContractId AdvancedPayment)
      -- ^ New AdvancedPayment contract if remaining amount exists, None if fully withdrawn
  deriving (Eq, Show)

data AdvancedPayment_Unlock_Result = AdvancedPayment_Unlock_Result
  with
    advancedPaymentCid : ContractId AdvancedPayment
      -- ^ Updated AdvancedPayment contract with reduced locked amount
  deriving (Eq, Show)

data AdvancedPayment_Cancel_Result = AdvancedPayment_Cancel_Result {}
  deriving (Eq, Show)

data AdvancedPayment_Expire_Result = AdvancedPayment_Expire_Result {}
  deriving (Eq, Show)

data AdvancedPayment_TopUp_Result = AdvancedPayment_TopUp_Result
  with
    advancedPaymentCid : ContractId AdvancedPayment
      -- ^ Updated AdvancedPayment contract with increased locked amount
  deriving (Eq, Show)

-- | Active advanced payment contract
template AdvancedPayment
  with
    dso : Party
      -- ^ DSO party reference
    owner : Party
      -- ^ Amulet owner
    provider : Party
      -- ^ Service provider
    app : Party
      -- ^ Application operator (signatory, controls withdraw/cancel)
    lockedAmulet : ContractId LockedAmulet
      -- ^ Reference to locked funds
    lockedAmount : Decimal
      -- ^ Current locked amount
    minimumAmount : Decimal
      -- ^ Minimum to keep for unpaid services
    expiresAt : Time
      -- ^ Lock expiry time
    description : Optional Text
      -- ^ Description of payment purpose
    reference : Optional Text
      -- ^ External reference number (invoice, PO, order ID)
  where
    signatory owner, app, provider

    ensure lockedAmount > 0.0
        && minimumAmount >= 0.0
        && owner /= app
        && owner /= provider
        && app /= provider

    choice AdvancedPayment_Withdraw : AdvancedPayment_Withdraw_Result
      -- ^ App withdraws amount for services rendered
      with
        amount : Decimal
          -- ^ Amount to withdraw
        appTransferContext : AppTransferContext
          -- ^ Transfer context
        withdrawReason : Optional Text
          -- ^ Optional reason for withdrawal (service description)
      controller app
      do
        assertMsg "Withdraw amount must be positive" $ amount > 0.0
        assertMsg "Withdraw amount exceeds locked amount" $ amount <= lockedAmount

        -- Build beneficiaries using provider (has FeaturedAppRight)
        let beneficiaries = Some [AppRewardBeneficiary with
              beneficiary = provider
              weight = 1.0]

        -- Unlock the locked amulet
        unlockedResult <- exercise lockedAmulet LockedAmulet_Unlock with
          openRoundCid = appTransferContext.openMiningRound

        -- Get actual unlocked amount
        unlockedAmulet <- fetch unlockedResult.amuletSum.amulet
        let actualUnlockedAmount = unlockedAmulet.amount.initialAmount

        -- Adjust withdrawal if actual amount is less than expected
        let effectiveWithdraw = min amount actualUnlockedAmount
        let remainingAmount = actualUnlockedAmount - effectiveWithdraw

        -- Create outputs: payment to app + remaining locked (if any)
        let appOutput = TransferOutput with
              receiver = app
              receiverFeeRatio = 0.0
              amount = effectiveWithdraw
              lock = None

        let remainingOutput = if remainingAmount > 0.0
              then [TransferOutput with
                      receiver = owner
                      receiverFeeRatio = 0.0
                      amount = remainingAmount
                      lock = Some $ TimeLock with
                        holders = [app]
                        expiresAt = expiresAt
                        optContext = Some (buildLockContext reference)]
              else []

        -- Execute transfer
        let transfer = Transfer with
              sender = owner
              provider = provider
              inputs = [InputAmulet unlockedResult.amuletSum.amulet]
              outputs = appOutput :: remainingOutput
              beneficiaries = beneficiaries

        transferResult <- exerciseAppTransfer dso appTransferContext transfer

        -- Create new AdvancedPayment if remaining amount exists
        advancedPaymentCid <- if remainingAmount > 0.0
          then do
            -- Extract locked amulet from results (second output)
            let newLockedCid = extractLockedAmulet transferResult.createdAmulets
            newCid <- create this with
              lockedAmulet = newLockedCid
              lockedAmount = remainingAmount
            pure $ Some newCid
          else pure None

        pure AdvancedPayment_Withdraw_Result with advancedPaymentCid

    choice AdvancedPayment_Unlock : AdvancedPayment_Unlock_Result
      -- ^ Owner unlocks partial amount (must keep minimumAmount)
      with
        amount : Decimal
          -- ^ Amount to unlock
        appTransferContext : AppTransferContext
          -- ^ Transfer context
      controller owner
      do
        assertMsg "Unlock amount must be positive" $ amount > 0.0
        let remainingAmount = lockedAmount - amount
        assertMsg "Must keep at least minimum amount locked" $ remainingAmount >= minimumAmount

        -- Build beneficiaries using provider
        let beneficiaries = Some [AppRewardBeneficiary with
              beneficiary = provider
              weight = 1.0]

        -- Unlock the locked amulet
        unlockedResult <- exercise lockedAmulet LockedAmulet_Unlock with
          openRoundCid = appTransferContext.openMiningRound

        -- Get actual unlocked amount
        unlockedAmulet <- fetch unlockedResult.amuletSum.amulet
        let actualUnlockedAmount = unlockedAmulet.amount.initialAmount

        -- Adjust for actual amount
        let effectiveUnlock = min amount actualUnlockedAmount
        let actualRemaining = actualUnlockedAmount - effectiveUnlock

        assertMsg "Actual remaining must meet minimum requirement" $ actualRemaining >= minimumAmount

        -- Create outputs: unlocked to owner + remaining locked
        let ownerOutput = TransferOutput with
              receiver = owner
              receiverFeeRatio = 0.0
              amount = effectiveUnlock
              lock = None

        let remainingOutput = TransferOutput with
              receiver = owner
              receiverFeeRatio = 0.0
              amount = actualRemaining
              lock = Some $ TimeLock with
                holders = [app]
                expiresAt = expiresAt
                optContext = Some (buildLockContext reference)

        -- Execute transfer
        let transfer = Transfer with
              sender = owner
              provider = provider
              inputs = [InputAmulet unlockedResult.amuletSum.amulet]
              outputs = [ownerOutput, remainingOutput]
              beneficiaries = beneficiaries

        transferResult <- exerciseAppTransfer dso appTransferContext transfer

        -- Extract locked amulet (second output)
        let newLockedCid = extractLockedAmulet transferResult.createdAmulets

        -- Create new AdvancedPayment with remaining amount
        advancedPaymentCid <- create this with
          lockedAmulet = newLockedCid
          lockedAmount = actualRemaining

        pure AdvancedPayment_Unlock_Result with advancedPaymentCid

    choice AdvancedPayment_Cancel : AdvancedPayment_Cancel_Result
      -- ^ App cancels and returns all funds to owner
      with
        appTransferContext : AppTransferContext
          -- ^ Transfer context
      controller app
      do
        -- Build beneficiaries using provider (has FeaturedAppRight)
        let beneficiaries = Some [AppRewardBeneficiary with
              beneficiary = provider
              weight = 1.0]

        -- Unlock fully and return to owner
        unlockedResult <- exercise lockedAmulet LockedAmulet_Unlock with
          openRoundCid = appTransferContext.openMiningRound

        -- Get actual unlocked amount
        unlockedAmulet <- fetch unlockedResult.amuletSum.amulet
        let actualUnlockedAmount = unlockedAmulet.amount.initialAmount

        -- Transfer all to owner (unlocked)
        let ownerOutput = TransferOutput with
              receiver = owner
              receiverFeeRatio = 0.0
              amount = actualUnlockedAmount
              lock = None

        let transfer = Transfer with
              sender = owner
              provider = provider  -- Provider has FeaturedAppRight
              inputs = [InputAmulet unlockedResult.amuletSum.amulet]
              outputs = [ownerOutput]
              beneficiaries = beneficiaries

        _ <- exerciseAppTransfer dso appTransferContext transfer

        pure AdvancedPayment_Cancel_Result

    choice AdvancedPayment_Expire : AdvancedPayment_Expire_Result
      -- ^ Owner unlocks fully after expiry
      with
        appTransferContext : AppTransferContext
          -- ^ Transfer context
      controller owner
      do
        now <- getTime
        assertMsg "Contract has not expired yet" $ now >= expiresAt

        -- Build beneficiaries using provider (has FeaturedAppRight)
        let beneficiaries = Some [AppRewardBeneficiary with
              beneficiary = provider
              weight = 1.0]

        -- Unlock fully and return to owner
        unlockedResult <- exercise lockedAmulet LockedAmulet_Unlock with
          openRoundCid = appTransferContext.openMiningRound

        -- Get actual unlocked amount
        unlockedAmulet <- fetch unlockedResult.amuletSum.amulet
        let actualUnlockedAmount = unlockedAmulet.amount.initialAmount

        -- Transfer all to owner (unlocked)
        let ownerOutput = TransferOutput with
              receiver = owner
              receiverFeeRatio = 0.0
              amount = actualUnlockedAmount
              lock = None

        let transfer = Transfer with
              sender = owner
              provider = provider  -- Provider has FeaturedAppRight
              inputs = [InputAmulet unlockedResult.amuletSum.amulet]
              outputs = [ownerOutput]
              beneficiaries = beneficiaries

        _ <- exerciseAppTransfer dso appTransferContext transfer

        pure AdvancedPayment_Expire_Result

    choice AdvancedPayment_TopUp : AdvancedPayment_TopUp_Result
      -- ^ Owner adds more funds and extends expiry
      with
        topUpInputs : [ContractId Amulet]
          -- ^ Additional amulets to add
        topUpAmount : Decimal
          -- ^ Amount to add
        newExpiresAt : Time
          -- ^ New expiry time (must be after existing)
        appTransferContext : AppTransferContext
          -- ^ Transfer context
      controller owner
      do
        assertMsg "Top-up amount must be positive" $ topUpAmount > 0.0
        assertMsg "New expiry must be after existing expiry" $ newExpiresAt > expiresAt

        -- Build beneficiaries using provider
        let beneficiaries = Some [AppRewardBeneficiary with
              beneficiary = provider
              weight = 1.0]

        -- Verify owner has sufficient funds for top-up
        inputAmount <- verifyAmulets dso topUpInputs
        assertMsg "Insufficient funds for top-up" $ inputAmount >= topUpAmount

        -- Unlock existing locked amulet
        unlockedResult <- exercise lockedAmulet LockedAmulet_Unlock with
          openRoundCid = appTransferContext.openMiningRound

        -- Get actual unlocked amount
        unlockedAmulet <- fetch unlockedResult.amuletSum.amulet
        let actualUnlockedAmount = unlockedAmulet.amount.initialAmount

        -- Create combined locked output (actual existing + top-up)
        let totalNewAmount = actualUnlockedAmount + topUpAmount
        let combinedLockOutput = TransferOutput with
              receiver = owner
              receiverFeeRatio = 0.0
              amount = totalNewAmount
              lock = Some $ TimeLock with
                holders = [app]
                expiresAt = newExpiresAt
                optContext = Some (buildLockContext reference)

        -- Execute transfer combining existing + new funds
        let transfer = Transfer with
              sender = owner
              provider = provider
              inputs = InputAmulet unlockedResult.amuletSum.amulet :: map InputAmulet topUpInputs
              outputs = [combinedLockOutput]
              beneficiaries = beneficiaries

        transferResult <- exerciseAppTransfer dso appTransferContext transfer

        -- Extract the single locked output (use helper for graceful error handling)
        let newLockedCid = extractLockedAmulet transferResult.createdAmulets

        -- Create new AdvancedPayment with updated amount and expiry
        advancedPaymentCid <- create this with
          lockedAmulet = newLockedCid
          lockedAmount = totalNewAmount
          expiresAt = newExpiresAt

        pure AdvancedPayment_TopUp_Result with advancedPaymentCid

-- | Helper function to extract locked amulet from transfer results
-- Handles case where there may be change amulets before the locked one
extractLockedAmulet : [CreatedAmulet] -> ContractId LockedAmulet
extractLockedAmulet [] = error "No locked amulet in transfer results"
extractLockedAmulet (TransferResultLockedAmulet cid :: _) = cid
extractLockedAmulet (_ :: rest) = extractLockedAmulet rest

-- | Helper function to verify amulets and return total amount
verifyAmulets : Party -> [ContractId Amulet] -> Update Decimal
verifyAmulets dso amulets = do
  let
    verifyAmulet amuletCid = do
      amulet <- fetch amuletCid
      assertMsg "Amulet DSO must match" $ amulet.dso == dso
      pure amulet.amount.initialAmount

  amounts <- mapA verifyAmulet amulets
  pure $ sum amounts
