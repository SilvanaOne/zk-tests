### Stage 1 – Build ########################################################
# Use the official Rust Alpine image for the arm64 architecture as the
# builder stage. This already contains a musl-based toolchain which lets us
# build statically-linked binaries that are ideal for Nitro Enclaves.
# FROM --platform=linux/arm64 rust:1.87-alpine AS builder
FROM --platform=linux/arm64 rust@sha256:126df0f2a57e675f9306fe180b833982ffb996e90a92a793bb75253cfeed5475 AS builder
# Install build dependencies

RUN apk add --no-cache build-base musl-dev
# from any Alpine 3.22 container
RUN apk info -e build-base
# → build-base-0.5-r3
RUN apk info -e musl-dev
# → musl-dev-1.2.4-r2

# Workdir inside the container
WORKDIR /app

# Pre-add the musl target (the default on Alpine, but be explicit)
RUN rustup target add aarch64-unknown-linux-musl

# Copy the Rust sources into the build context.
# We copy the Cargo.toml/Cargo.lock first so that dependency layers are
# cached when only application code changes.
COPY server/Cargo.toml server/Cargo.lock ./
# Copy workspace configuration and vendored crates for reproducible offline build
COPY server/.cargo ./.cargo
COPY server/vendor ./vendor
# Application source
COPY server/src ./src

# Build in release mode for arm64 musl target
RUN cargo build --release --offline --target aarch64-unknown-linux-musl

### Stage 2 – Runtime ######################################################
# Use a minimal Alpine image for the final enclave rootfs.
FROM --platform=linux/arm64 alpine:3.22 AS runtime

# Create a non-root user (optional but recommended)
RUN addgroup -S app && adduser -S app -G app

# Application directory
WORKDIR /app

# Copy the statically-linked executable from the builder stage
COPY --from=builder /app/target/aarch64-unknown-linux-musl/release/tee-arm /app/tee-arm

# Ensure the binary is executable and owned by the non-root user
RUN chmod +x /app/tee-arm && chown app:app /app/tee-arm
USER app

# The Nitro Enclave entrypoint is simply the application binary
ENTRYPOINT ["/app/tee-arm"] 