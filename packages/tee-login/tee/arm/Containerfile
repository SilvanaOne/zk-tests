ARG TARGETPLATFORM=linux/arm64

### Stage 1 – Build ########################################################
# Use the official Rust Alpine image for the arm64 architecture as the
# builder stage. This already contains a musl-based toolchain which lets us
# build statically-linked binaries that are ideal for Nitro Enclaves.
# 1.87-alpine
FROM docker.io/library/rust@sha256:fa3f412044d347294ad9c21eb3c9922a5e12e57b645ae53bbd27b8bc26173a7e AS builder

# Install build dependencies
ENV SOURCE_DATE_EPOCH=0  
RUN apk add --no-cache build-base musl-dev

# Workdir inside the container
WORKDIR /app

# Pre-add the musl target (the default on Alpine, but be explicit)
RUN rustup target add aarch64-unknown-linux-musl

# Copy the Rust sources into the build context.
# We copy the Cargo.toml/Cargo.lock first so that dependency layers are
# cached when only application code changes.
RUN mkdir -p server
RUN mkdir -p forwarder
COPY server/Cargo.toml server/Cargo.lock ./server
COPY server/src ./server/src
COPY server/vendor ./server/vendor
COPY server/.cargo ./server/.cargo
COPY forwarder/Cargo.toml forwarder/Cargo.lock ./forwarder
COPY forwarder/src ./forwarder/src
COPY forwarder/vendor ./forwarder/vendor
COPY forwarder/.cargo ./forwarder/.cargo

ENV TARGET=aarch64-unknown-linux-musl
ENV RUSTFLAGS="-C target-feature=+crt-static -C link-arg=-Wl,--build-id=none"
ENV CARGO_INCREMENTAL=0
ENV CARGOFLAGS="--locked --no-default-features --release --target ${TARGET}"
# Build in release mode for arm64 musl target
RUN cd server && cargo build --release --locked --offline --target aarch64-unknown-linux-musl
RUN cd forwarder && cargo build --release --locked --offline --target aarch64-unknown-linux-musl


### Stage 2 – Runtime ######################################################
# Use a minimal Alpine image for the final enclave rootfs.
# alpine:3.22
FROM docker.io/library/alpine@sha256:008448246686fe28544e36ba89e7bc7fbe6dad8a2ccdef576875c74298c46348 AS runtime

# Install runtime dependencies (socat for vsock forwarding, jq for JSON parsing, GNU cpio for reproducible builds)
RUN apk add --no-cache socat jq cpio

# Create a non-root user (optional but recommended)
RUN addgroup -S app && adduser -S app -G app

# Application directory
WORKDIR /app
ENV KBUILD_BUILD_TIMESTAMP=1

# Create a simple init process for the enclave
RUN <<-EOF
cat > /app/init << 'INIT_SCRIPT'
#!/bin/sh
# Simple init process for ARM64 enclave
set -e

# Mount essential filesystems
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev

# Load NSM driver if available
if [ -f /nsm.ko ]; then
    insmod /nsm.ko || echo "Failed to load NSM driver"
fi

# Create device nodes
mknod /dev/console c 5 1 2>/dev/null || true
mknod /dev/null c 1 3 2>/dev/null || true
mknod /dev/zero c 1 5 2>/dev/null || true

# Start the application
exec /app/run.sh "\$@"
INIT_SCRIPT
chmod +x /app/init
EOF

# Copy the statically-linked executable from the builder stage
COPY --from=builder /app/server/target/aarch64-unknown-linux-musl/release/server /app/server
COPY --from=builder /app/forwarder/target/aarch64-unknown-linux-musl/release/forwarder /app/forwarder
COPY data/allowed_endpoints.yaml /app/allowed_endpoints.yaml
COPY data/run.sh /app/run.sh

# We'll copy the NSM driver in the nitro-builder stage since it's not available here yet

# Ensure the binary is executable and owned by the non-root user
RUN chmod +x /app/server && chown app:app /app/server
RUN chmod +x /app/forwarder && chown app:app /app/forwarder
RUN chmod +x /app/run.sh && chown app:app /app/run.sh
# RUN find /app -exec touch -hcd '@0' {} +
USER app

# The Nitro Enclave entrypoint is simply the application binary
ENTRYPOINT ["/app/run.sh"] 


### Stage 3 – Initramfs Builder ############################################
FROM runtime AS initramfs-builder

USER root
WORKDIR /app

# Download NSM driver
RUN wget -O /app/nsm.ko https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/nsm.ko

# Create the complete initramfs
RUN <<-EOF
    set -eux
    cd /app
    
    # Create essential directories
    mkdir -p proc sys dev tmp var/log
    
    # Set proper permissions
    chmod +x init server forwarder run.sh
    
    # Set timestamps for reproducible builds
    find . -exec touch -hcd "@0" "{}" +
    
    # Create the cpio archive (gzipped like x86 version)
    find . -print0 \
    | sort -z \
    | cpio \
        --null \
        --create \
        --verbose \
        --reproducible \
        --format=newc \
    | gzip --best \
    > /app/rootfs.cpio
EOF


### Stage 4 – Nitro CLI Builder ############################################
# Use Amazon Linux 2023 for nitro-cli to build EIF files
FROM amazonlinux:2023@sha256:2ae982a3cc43011aaf80f42b086451c0c562a319b2e020e089f35338dfda1360 AS nitro-builder

ARG NITRO_COMMIT=483114f1da3bad913ad1fb7d5c00dadacc6cbae6
ENV SOURCE_DATE_EPOCH=0 \
    RUSTFLAGS="-C link-arg=-Wl,--build-id=none" \
    CARGO_INCREMENTAL=0

# Minimal tool-chain for a static binary
RUN yum install -y --setopt=install_weak_deps=False \
    git clang rust cargo openssl-devel tar wget && \
    yum clean all

# Clone + checkout exactly one commit, then build with --locked
RUN git clone https://github.com/aws/aws-nitro-enclaves-image-format.git /src/nitro-cli && \
    cd /src/nitro-cli/eif_build && \
    git checkout ${NITRO_COMMIT} && \
    cargo build --release  --target aarch64-unknown-linux-gnu && \
    strip ../target/aarch64-unknown-linux-gnu/release/eif_build && \
    mv ../target/aarch64-unknown-linux-gnu/release/eif_build /usr/local/bin

# Download ARM64 kernel files from AWS Nitro Enclaves CLI repository
RUN wget -O /Image https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/Image && \
    wget -O /Image.config https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/Image.config

# Copy the rootfs.cpio from the initramfs-builder stage (includes NSM driver)
COPY --from=initramfs-builder /app/rootfs.cpio /app/rootfs.cpio

# Set working directory
WORKDIR /workspace

# Default command
CMD ["/bin/bash"]