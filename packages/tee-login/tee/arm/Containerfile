ARG TARGETPLATFORM=linux/arm64

### Stage 1 – Build ########################################################
# Use the official Rust Alpine image for the arm64 architecture as the
# builder stage. This already contains a musl-based toolchain which lets us
# build statically-linked binaries that are ideal for Nitro Enclaves.
# 1.87-alpine
FROM docker.io/library/rust@sha256:fa3f412044d347294ad9c21eb3c9922a5e12e57b645ae53bbd27b8bc26173a7e AS builder

# Install build dependencies
ENV SOURCE_DATE_EPOCH=0  
RUN apk add --no-cache build-base musl-dev

# Workdir inside the container
WORKDIR /app

# Pre-add the musl target (the default on Alpine, but be explicit)
RUN rustup target add aarch64-unknown-linux-musl

# Copy the entire workspace structure
COPY Cargo.toml Cargo.lock ./
COPY src ./src
COPY server ./server
COPY forwarder ./forwarder

ENV TARGET=aarch64-unknown-linux-musl
ENV RUSTFLAGS="-C target-feature=+crt-static -C link-arg=-Wl,--build-id=none"
ENV CARGO_INCREMENTAL=0

# Build the workspace (init, aws, system) like x86 version
RUN cargo build --workspace --release --target aarch64-unknown-linux-musl

# Build server and forwarder separately
WORKDIR /app/server
RUN cargo build --release --target aarch64-unknown-linux-musl

WORKDIR /app/forwarder
RUN cargo build --release --target aarch64-unknown-linux-musl

WORKDIR /app


### Stage 2 – Runtime ######################################################
# Use a minimal Alpine image for the final enclave rootfs.
# alpine:3.22
FROM docker.io/library/alpine@sha256:008448246686fe28544e36ba89e7bc7fbe6dad8a2ccdef576875c74298c46348 AS runtime

# Install runtime dependencies (socat for vsock forwarding, jq for JSON parsing, GNU cpio for reproducible builds)
RUN apk add --no-cache socat jq cpio

# Create a non-root user (optional but recommended)
RUN addgroup -S app && adduser -S app -G app

# Application directory
WORKDIR /app
ENV KBUILD_BUILD_TIMESTAMP=1

# The init process will be built from the Rust workspace

# Copy the statically-linked executables from the builder stage (no custom init needed)
COPY --from=builder /app/server/target/aarch64-unknown-linux-musl/release/server /app/server
COPY --from=builder /app/forwarder/target/aarch64-unknown-linux-musl/release/forwarder /app/forwarder
COPY --from=builder /app/target/aarch64-unknown-linux-musl/release/init /app/init
COPY data/allowed_endpoints.yaml /app/allowed_endpoints.yaml
COPY data/run.sh /app/run.sh

# We'll copy the NSM driver in the nitro-builder stage since it's not available here yet

# Ensure the binaries are executable and owned by the non-root user
RUN chmod +x /app/server && chown app:app /app/server
RUN chmod +x /app/forwarder && chown app:app /app/forwarder
RUN chmod +x /app/init && chown app:app /app/init
RUN chmod +x /app/run.sh && chown app:app /app/run.sh
# RUN find /app -exec touch -hcd '@0' {} +
USER app

# The Nitro Enclave entrypoint is simply the application binary
ENTRYPOINT ["/app/run.sh"] 


### Stage 3 – Initramfs Builder ############################################
FROM runtime AS initramfs-builder

USER root
WORKDIR /build_cpio

# Download NSM driver
RUN wget -O /nsm.ko https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/nsm.ko
 # Download and use official AWS bootstrap init for ARM64
# Build init binary (like x86 version) - no need to download AWS init
  
# Create the complete initramfs structure similar to x86
RUN <<-EOF
    set -eux
    
    # Create initramfs directory structure
    mkdir -p initramfs/proc initramfs/sys initramfs/dev initramfs/tmp initramfs/run initramfs/var/log
    mkdir -p initramfs/etc/ssl/certs
    mkdir -p initramfs/opt/aws/acm/lib initramfs/opt/aws/acm
    mkdir -p initramfs/lib initramfs/usr/lib
    mkdir -p initramfs/sbin initramfs/bin
    
    # Create essential device files (similar to x86 version)
    mknod initramfs/dev/console c 5 1
    mknod initramfs/dev/null c 1 3
    mknod initramfs/dev/zero c 1 5
    mknod initramfs/dev/random c 1 8
    mknod initramfs/dev/urandom c 1 9
    chmod 666 initramfs/dev/console initramfs/dev/null initramfs/dev/zero initramfs/dev/random initramfs/dev/urandom
    
    # Copy NSM driver
    cp /nsm.ko initramfs/nsm.ko
    
    # Copy built init binary (like x86 version)
    cp /app/init initramfs/init
    
    chmod +x initramfs/init
    
    # Copy application binaries
    cp /app/server initramfs/server
    cp /app/forwarder initramfs/forwarder
    cp /app/run.sh initramfs/run.sh
    cp /app/allowed_endpoints.yaml initramfs/allowed_endpoints.yaml
    
    # No need for cmd/env files - using custom init like x86 version
    
    # Copy essential binaries
    cp /bin/sh initramfs/sh
    cp /usr/bin/jq initramfs/jq
    cp /usr/bin/socat initramfs/socat
    
    # Copy busybox and create essential symlinks
    cp /bin/busybox initramfs/busybox
    ln -sf busybox initramfs/ip
    ln -sf busybox initramfs/ifconfig
    ln -sf busybox initramfs/ps
    ln -sf busybox initramfs/ls
    ln -sf busybox initramfs/cat
    ln -sf busybox initramfs/echo
    ln -sf busybox initramfs/mount
    ln -sf busybox initramfs/umount
    ln -sf busybox initramfs/mkdir
    ln -sf busybox initramfs/rmdir
    ln -sf busybox initramfs/chmod
    ln -sf busybox initramfs/chown
    ln -sf busybox initramfs/cp
    ln -sf busybox initramfs/mv
    ln -sf busybox initramfs/rm
    ln -sf busybox initramfs/kill
    ln -sf busybox initramfs/killall
    ln -sf busybox initramfs/ps
    ln -sf busybox initramfs/top
    ln -sf busybox initramfs/sleep
    ln -sf busybox initramfs/test
    ln -sf busybox initramfs/[
    ln -sf busybox initramfs/grep
    ln -sf busybox initramfs/sed
    ln -sf busybox initramfs/awk
    ln -sf busybox initramfs/tr
    ln -sf busybox initramfs/sort
    ln -sf busybox initramfs/head
    ln -sf busybox initramfs/tail
    
    # Copy musl libc (required for all binaries)
    cp /lib/libc.musl-aarch64.so.1 initramfs/lib/libc.musl-aarch64.so.1
    cp /lib/ld-musl-aarch64.so.1 initramfs/lib/ld-musl-aarch64.so.1
    
    # Create symlinks for compatibility
    ln -sf libc.musl-aarch64.so.1 initramfs/lib/libc.so.6
    ln -sf ld-musl-aarch64.so.1 initramfs/lib/ld-linux-aarch64.so.1
    
    # Verify libc files exist and are executable
    ls -la initramfs/lib/libc.musl-aarch64.so.1
    ls -la initramfs/lib/ld-musl-aarch64.so.1
    
    # Test that our binaries can find libc
    echo "Testing binary dependencies:"
    ldd initramfs/init 2>/dev/null || echo "init: statically linked or musl (ldd not available)"
    ldd initramfs/server 2>/dev/null || echo "server: statically linked or musl"
    ldd initramfs/sh 2>/dev/null || echo "sh: statically linked or musl"
    
    # Verify binaries are executable
    test -x initramfs/init && echo "init: executable" || echo "init: NOT executable"
    test -x initramfs/server && echo "server: executable" || echo "server: NOT executable"
    test -x initramfs/sh && echo "sh: executable" || echo "sh: NOT executable"
    
    # Copy SSL certificates
    cp -r /etc/ssl/certs/* initramfs/etc/ssl/certs/ 2>/dev/null 
    ln -sf /etc/ssl/certs/ca-certificates.crt initramfs/ca-certificates.crt
    
    # Copy ACM files from parent system if they exist
    # These files are created by the nitro-enclaves-acm service on the parent
    if [ -f "/opt/aws/acm/cert_chain.pem" ]; then \
        cp /opt/aws/acm/cert_chain.pem initramfs/opt/aws/acm/; \
        echo "Copied certificate chain to enclave"; \
    else \
        echo "Warning: Certificate chain not found. Make sure nitro-enclaves-acm service is running."; \
        touch initramfs/opt/aws/acm/cert_chain.pem; \
    fi

    if [ -f "/opt/aws/acm/private_key.pem" ]; then \
        cp /opt/aws/acm/private_key.pem initramfs/opt/aws/acm/; \
        echo "Copied private key to enclave"; \
    else \
        echo "Warning: Private key not found. Make sure nitro-enclaves-acm service is running."; \
        touch initramfs/opt/aws/acm/private_key.pem; \
    fi
    
    # Set proper permissions
    chmod +x initramfs/init initramfs/server initramfs/forwarder initramfs/run.sh initramfs/sh initramfs/jq initramfs/socat
    
    # Set timestamps for reproducible builds
    cd initramfs
    find . -exec touch -hcd "@0" "{}" +
    ls -lh
    
    # Create the cpio archive (gzipped like x86 version)
    find . -print0 \
    | sort -z \
    | cpio \
        --null \
        --create \
        --verbose \
        --reproducible \
        --format=newc \
    | gzip --best \
    > /build_cpio/rootfs.cpio
EOF


### Stage 4 – Nitro CLI Builder ############################################
# Use Amazon Linux 2023 for nitro-cli to build EIF files
FROM amazonlinux:2023@sha256:2ae982a3cc43011aaf80f42b086451c0c562a319b2e020e089f35338dfda1360 AS nitro-builder

ARG NITRO_COMMIT=483114f1da3bad913ad1fb7d5c00dadacc6cbae6
ENV SOURCE_DATE_EPOCH=0 \
    RUSTFLAGS="-C link-arg=-Wl,--build-id=none" \
    CARGO_INCREMENTAL=0

# Minimal tool-chain for a static binary
RUN yum install -y --setopt=install_weak_deps=False \
    git clang rust cargo openssl-devel tar wget && \
    yum clean all

# Clone + checkout exactly one commit, then build with --locked
RUN git clone https://github.com/aws/aws-nitro-enclaves-image-format.git /src/nitro-cli && \
    cd /src/nitro-cli/eif_build && \
    git checkout ${NITRO_COMMIT} && \
    cargo build --release  --target aarch64-unknown-linux-gnu && \
    strip ../target/aarch64-unknown-linux-gnu/release/eif_build && \
    mv ../target/aarch64-unknown-linux-gnu/release/eif_build /usr/local/bin

# Download ARM64 kernel files from AWS Nitro Enclaves CLI repository
RUN wget -O /Image https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/Image && \
    wget -O /Image.config https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/Image.config && \
    wget -O /linuxkit https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/linuxkit && \
    wget -O /cmdline https://raw.githubusercontent.com/aws/aws-nitro-enclaves-cli/main/blobs/aarch64/cmdline && \
    chmod +x /cmdline

# Copy the rootfs.cpio from the initramfs-builder stage (includes NSM driver)
COPY --from=initramfs-builder /build_cpio/rootfs.cpio /rootfs.cpio

RUN ls -lh /



# Set working directory
WORKDIR /workspace

# Build the EIF file as final step
RUN eif_build \
    --arch aarch64 \
    --kernel /Image \
    --kernel_config /Image.config \
    --ramdisk /rootfs.cpio \
    --output /workspace/tee-arm.eif \
    --cmdline "reboot=k panic=1 pci=off nomodules console=ttyS0 random.trust_cpu=on root=/dev/ram0"

# Default command
CMD ["/bin/bash"]