# Copyright (c), Mysten Labs, Inc.
# SPDX-License-Identifier: Apache-2.0

FROM alpine:3.18 AS builder
RUN apk add --no-cache build-base cmake ninja linux-headers git \
    musl-dev libc-dev libffi-dev openssl-dev zlib-dev libseccomp-dev \
    linux-tools util-linux coreutils tar xz curl ca-certificates \
    libressl-dev libressl-static

ENV RUSTUP_HOME=/root/.rustup \
    CARGO_HOME=/root/.cargo \
    PATH=$PATH:/root/.cargo/bin
RUN curl -sSf https://sh.rustup.rs | sh -s -- -y --profile minimal && \
    rustup target add aarch64-unknown-linux-musl

# Build eif_build; link statically against libressl
ENV OPENSSL_STATIC=1
RUN cargo install eif_build --locked --target aarch64-unknown-linux-musl

# ------------------------------------------------------------------
# Build the enclave kernel and NSM driver on ARM64
# ------------------------------------------------------------------
FROM alpine:3.18 AS kernel-build
RUN apk add --no-cache build-base bc flex bison openssl-dev elfutils-dev git \
    ncurses-dev bash tar xz
WORKDIR /src
RUN git clone --depth=1 -b v6.6 https://github.com/torvalds/linux.git .
# Configure a minimal kernel with Nitro Enclaves support
RUN make ARCH=arm64 defconfig && \
    scripts/config -m NITRO_ENCLAVES && \
    scripts/config -e VIRTIO_VSOCK && \
    scripts/config -e VIRTIO_MMIO
RUN make -j$(nproc) ARCH=arm64 Image modules
# Export the kernel, driver, and config for later stages
RUN mkdir /out && \
    cp arch/arm64/boot/Image /out/Image && \
    cp drivers/virt/nitro_enclaves/nitro_enclaves.ko /out/nsm.ko && \
    cp .config /out/linux.config

FROM alpine:3.19 AS runtime
COPY --from=builder /root/.cargo/bin/eif_build /usr/local/bin/
ENTRYPOINT ["eif_build", "--help"]

# Build BusyBox static
WORKDIR /root
RUN curl -LO https://busybox.net/downloads/busybox-1.36.1.tar.bz2 && \
    tar xf busybox-1.36.1.tar.bz2 && cd busybox-1.36.1 && \
    make defconfig && sed -i 's/.*CONFIG_STATIC.*/CONFIG_STATIC=y/' .config && \
    make -j$(nproc) && mkdir -p /out && cp busybox /out/busybox

FROM scratch as base
ENV TARGET=aarch64-unknown-linux-musl
ENV RUSTFLAGS="-C target-feature=+crt-static"
ENV CARGOFLAGS="--locked --no-default-features --release --target ${TARGET}"
ENV OPENSSL_STATIC=true

# Build Linux kernel + NSM
WORKDIR /root

FROM alpine:3.18 AS alpine-runtime
RUN apk add --no-cache \
        musl \
        libseccomp \
        ca-certificates \
        jq \
        socat


FROM builder as build
# environment for Rust static builds
ENV TARGET=aarch64-unknown-linux-musl \
    RUSTFLAGS="-C target-feature=+crt-static" \
    CARGOFLAGS="--locked --no-default-features --release --target=${TARGET}" \
    OPENSSL_STATIC=true
COPY . .
RUN cargo build --workspace --locked --no-default-features --release --target ${TARGET}

WORKDIR /src/forwarder
# ENV RUSTFLAGS="-C target-feature=+crt-static -C relocation-model=static"
ENV LIBCLANG_PATH=/usr/lib
RUN cargo build --locked --no-default-features --release --target ${TARGET}

WORKDIR /src/server
# ENV RUSTFLAGS="-C target-feature=+crt-static -C relocation-model=static"
ENV LIBCLANG_PATH=/usr/lib
RUN cargo build --locked --no-default-features --release --target ${TARGET}


WORKDIR /build_cpio
ENV KBUILD_BUILD_TIMESTAMP=1

RUN mkdir initramfs/
# musl runtime (dynamic linker + libc) – only needed if any binary is *not* fully static
COPY --from=alpine-runtime /lib/ld-musl-aarch64.so.1 initramfs/lib/
COPY --from=alpine-runtime /lib/libc.musl-*.so*          initramfs/lib/

# libseccomp (only if your code or BusyBox was linked dynamically to it)
COPY --from=alpine-runtime /usr/lib/libseccomp.so.*      initramfs/lib/

# CA bundle for TLS
COPY --from=alpine-runtime /etc/ssl/certs/ca-certificates.crt initramfs/etc/ssl/certs/

# copy the statically‑linked BusyBox we built earlier
COPY --from=runtime /out/busybox initramfs/bin/busybox

# BusyBox already gives you /bin/sh; create a link instead of copying from StageX
RUN ln -s busybox initramfs/bin/sh

# jq and socat binaries
COPY --from=alpine-runtime /usr/bin/jq      initramfs/bin/
COPY --from=alpine-runtime /usr/bin/socat   initramfs/bin/
RUN mkdir initramfs/proc
RUN mkdir initramfs/run

RUN cp /target/${TARGET}/release/init initramfs
RUN cp /src/server/target/${TARGET}/release/server initramfs
RUN cp /src/forwarder/target/${TARGET}/release/forwarder initramfs
# RUN cp /src/server/traffic_forwarder.py initramfs/
RUN cp /src/server/run.sh initramfs/
RUN cp /src/server/allowed_endpoints.yaml initramfs/

COPY --from=kernel-build /out/nsm.ko initramfs/nsm.ko

RUN <<-EOF
    set -eux
    cd initramfs
    find . -exec touch -hcd "@0" "{}" +
    find . -print0 \
    | sort -z \
    | cpio \
        --null \
        --create \
        --verbose \
        --reproducible \
        --format=newc \
    | gzip --best \
    > /build_cpio/rootfs.cpio
EOF

WORKDIR /build_eif

# Bring in the freshly‑built ARM64 kernel and its config
COPY --from=kernel-build /out/Image /Image
COPY --from=kernel-build /out/linux.config /linux.config

RUN eif_build \
	--kernel /Image \
	--kernel_config /linux.config \
	--ramdisk /build_cpio/rootfs.cpio \
	--pcrs_output /nitro.pcrs \
	--output /nitro.eif \
	--cmdline 'reboot=k initrd=0x2000000,3228672 root=/dev/ram0 panic=1 pci=off nomodules console=ttyS0 i8042.noaux i8042.nomux i8042.nopnp i8042.dumbkbd'

FROM base as install
WORKDIR /rootfs
COPY --from=build /nitro.eif .
COPY --from=build /nitro.pcrs .
COPY --from=build /build_cpio/rootfs.cpio .

FROM scratch as package
COPY --from=install /rootfs .
