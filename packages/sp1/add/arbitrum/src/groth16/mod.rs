mod converter;
pub mod error_groth16;
mod verify;
mod converter_utils;
mod constants;
mod error;
pub mod hex_utils;

use crate::bn::Fr;
pub(crate) use converter::{load_groth16_proof_from_bytes, load_groth16_verifying_key_from_bytes};
pub(crate) use verify::*;

use error_groth16::Groth16Error;

use constants::VK_HASH_PREFIX_LENGTH;
use error::Error;

use alloc::vec::Vec;
use sha2::{Digest, Sha256};

/// The Groth16 verifying key for the current SP1 version
pub const GROTH16_VK_BYTES: &[u8] = include_bytes!("groth16_vk.bin");

/// A verifier for Groth16 zero-knowledge proofs.
#[derive(Debug)]
pub struct Groth16Verifier;

impl Groth16Verifier {
    /// Verifies an SP1 Groth16 proof, as generated by the SP1 SDK.
    pub fn verify(
        proof: &[u8],
        sp1_public_inputs: &[u8],
        sp1_vkey_hash: &str,
        groth16_vk: &[u8],
    ) -> Result<(), Groth16Error> {
        if proof.len() < VK_HASH_PREFIX_LENGTH {
            return Err(Groth16Error::GeneralError(Error::InvalidData));
        }

        // Hash the vk and get the first 4 bytes.
        let groth16_vk_hash: [u8; 4] = Sha256::digest(groth16_vk)[..VK_HASH_PREFIX_LENGTH]
            .try_into()
            .map_err(|_| Groth16Error::GeneralError(Error::InvalidData))?;

        // Check to make sure that this proof was generated by the groth16 proving key corresponding
        // to the given groth16_vk.
        if groth16_vk_hash != proof[..VK_HASH_PREFIX_LENGTH] {
            return Err(Groth16Error::Groth16VkeyHashMismatch);
        }

        let sp1_vkey_hash = decode_sp1_vkey_hash(sp1_vkey_hash)?;

        // Verify using SHA256 hashing for public inputs
        Self::verify_gnark_proof(
            &proof[VK_HASH_PREFIX_LENGTH..],
            &[sp1_vkey_hash, hash_public_inputs(sp1_public_inputs)],
            groth16_vk,
        )
    }

    /// Verifies a Gnark Groth16 proof using raw byte inputs.
    pub fn verify_gnark_proof(
        proof: &[u8],
        public_inputs: &[[u8; 32]],
        groth16_vk: &[u8],
    ) -> Result<(), Groth16Error> {
        let proof = load_groth16_proof_from_bytes(proof)?;
        let groth16_vk = load_groth16_verifying_key_from_bytes(groth16_vk)?;

        let public_inputs =
            public_inputs.iter().map(|input| Fr::from_slice(input).unwrap()).collect::<Vec<_>>();
        verify_groth16_algebraic(&groth16_vk, &proof, &public_inputs)
    }
}

/// Hashes the public inputs in the same format as the Plonk and Groth16 verifiers.
pub fn hash_public_inputs(public_inputs: &[u8]) -> [u8; 32] {
    let mut result: [u8; 32] = Sha256::digest(public_inputs).into();

    // The Plonk and Groth16 verifiers operate over a 254 bit field, so we need to zero
    // out the first 3 bits. The same logic happens in the SP1 Ethereum verifier contract.
    result[0] &= 0x1F;

    result
}

/// Decodes the sp1 vkey hash from the string from a call to `vk.bytes32`.
pub fn decode_sp1_vkey_hash(sp1_vkey_hash: &str) -> Result<[u8; 32], Groth16Error> {
    let bytes = hex_utils::decode(sp1_vkey_hash)
        .map_err(|_| Groth16Error::GeneralError(Error::InvalidProgramVkeyHash))?;
    bytes.try_into().map_err(|_| Groth16Error::GeneralError(Error::InvalidProgramVkeyHash))
}